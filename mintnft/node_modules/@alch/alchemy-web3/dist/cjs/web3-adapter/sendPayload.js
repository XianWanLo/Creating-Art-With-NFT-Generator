"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.makePayloadSender = void 0;
var tslib_1 = require("tslib");
var assert_never_1 = tslib_1.__importDefault(require("assert-never"));
var promises_1 = require("../util/promises");
var ALCHEMY_DISALLOWED_METHODS = [
    "eth_accounts",
    "eth_sendTransaction",
    "eth_sign",
    "eth_signTypedData_v3",
    "eth_signTypedData",
    "personal_sign",
];
function makePayloadSender(alchemySend, config, makePayload) {
    var currentWriteProvider = getEip1193Provider(config.writeProvider, makePayload);
    var sendPayload = function (payload) {
        var disallowedMethod = getDisallowedMethod(payload);
        if (!disallowedMethod) {
            try {
                return sendWithRetries(payload, alchemySend, config);
            }
            catch (alchemyError) {
                // Fallback to write provider, but if both fail throw the error from
                // Alchemy.
                if (!currentWriteProvider) {
                    throw alchemyError;
                }
                try {
                    return sendWithProvider(currentWriteProvider, payload);
                }
                catch (_a) {
                    throw alchemyError;
                }
            }
        }
        else {
            if (!currentWriteProvider) {
                throw new Error("No provider available for method \"" + disallowedMethod + "\"");
            }
            return sendWithProvider(currentWriteProvider, payload);
        }
    };
    function setWriteProvider(writeProvider) {
        currentWriteProvider = getEip1193Provider(writeProvider, makePayload);
    }
    return { sendPayload: sendPayload, setWriteProvider: setWriteProvider };
}
exports.makePayloadSender = makePayloadSender;
function getEip1193Provider(provider, makePayload) {
    if (!provider) {
        return undefined;
    }
    var anyProvider = provider;
    var sendMethod = (anyProvider.sendAsync
        ? anyProvider.sendAsync
        : anyProvider.send).bind(anyProvider);
    return {
        send: function (method, params) {
            return promises_1.promisify(function (callback) {
                return sendMethod(makePayload(method, params), callback);
            });
        },
    };
}
function sendWithProvider(provider, payload) {
    if (!Array.isArray(payload)) {
        var method = payload.method, params = payload.params;
        return provider.send(method, params);
    }
    else {
        // These providers don't support batches, sadly.
        return Promise.all(payload.map(function (_a) {
            var method = _a.method, params = _a.params;
            return provider.send(method, params);
        }));
    }
}
function getDisallowedMethod(payload) {
    var payloads = Array.isArray(payload) ? payload : [payload];
    var disallowedRequest = payloads.find(function (p) { return ALCHEMY_DISALLOWED_METHODS.indexOf(p.method) >= 0; }) ||
        undefined;
    return disallowedRequest && disallowedRequest.method;
}
function sendWithRetries(payload, alchemySend, _a) {
    var maxRetries = _a.maxRetries, retryInterval = _a.retryInterval, retryJitter = _a.retryJitter;
    return tslib_1.__awaiter(this, void 0, void 0, function () {
        var i, result, status_1, message, statusString;
        return tslib_1.__generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    i = 0;
                    _b.label = 1;
                case 1:
                    if (!(i < maxRetries + 1)) return [3 /*break*/, 5];
                    return [4 /*yield*/, alchemySend(payload)];
                case 2:
                    result = _b.sent();
                    switch (result.type) {
                        case "jsonrpc":
                            return [2 /*return*/, result.response];
                        case "rateLimit":
                            break;
                        case "networkError": {
                            status_1 = result.status, message = result.message;
                            statusString = status_1 !== 0 ? "(" + status_1 + ") " : "";
                            throw new Error(statusString + " " + message);
                        }
                        default:
                            return [2 /*return*/, assert_never_1.default(result)];
                    }
                    return [4 /*yield*/, promises_1.delay(retryInterval + ((retryJitter * Math.random()) | 0))];
                case 3:
                    _b.sent();
                    _b.label = 4;
                case 4:
                    i++;
                    return [3 /*break*/, 1];
                case 5: throw new Error("Rate limited for " + (maxRetries + 1) + " consecutive attempts.");
            }
        });
    });
}
