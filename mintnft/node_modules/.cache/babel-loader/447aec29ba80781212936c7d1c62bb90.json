{"ast":null,"code":"import { __assign, __awaiter, __generator, __read, __spread } from \"tslib\";\nimport Web3 from \"web3\";\nimport { hexToNumberString, toHex } from \"web3-utils\";\nimport { callWhenDone } from \"./util/promises\";\nimport { makeAlchemyContext } from \"./web3-adapter/alchemyContext\";\nvar DEFAULT_MAX_RETRIES = 3;\nvar DEFAULT_RETRY_INTERVAL = 1000;\nvar DEFAULT_RETRY_JITTER = 250;\nexport var AssetTransfersCategory;\n\n(function (AssetTransfersCategory) {\n  AssetTransfersCategory[\"EXTERNAL\"] = \"external\";\n  AssetTransfersCategory[\"INTERNAL\"] = \"internal\";\n  AssetTransfersCategory[\"TOKEN\"] = \"token\";\n})(AssetTransfersCategory || (AssetTransfersCategory = {}));\n\nexport function createAlchemyWeb3(alchemyUrl, config) {\n  var fullConfig = fillInConfigDefaults(config);\n\n  var _a = makeAlchemyContext(alchemyUrl, fullConfig),\n      provider = _a.provider,\n      senders = _a.senders,\n      setWriteProvider = _a.setWriteProvider;\n\n  var alchemyWeb3 = new Web3(provider);\n\n  alchemyWeb3.setProvider = function () {\n    throw new Error(\"setProvider is not supported in Alchemy Web3. To change the provider used for writes, use setWriteProvider() instead.\");\n  };\n\n  alchemyWeb3.setWriteProvider = setWriteProvider;\n  alchemyWeb3.alchemy = {\n    getTokenAllowance: function getTokenAllowance(params, callback) {\n      return callAlchemyMethod({\n        senders: senders,\n        callback: callback,\n        method: \"alchemy_getTokenAllowance\",\n        params: [params]\n      });\n    },\n    getTokenBalances: function getTokenBalances(address, contractAddresses, callback) {\n      return callAlchemyMethod({\n        senders: senders,\n        callback: callback,\n        method: \"alchemy_getTokenBalances\",\n        params: [address, contractAddresses],\n        processResponse: processTokenBalanceResponse\n      });\n    },\n    getTokenMetadata: function getTokenMetadata(address, callback) {\n      return callAlchemyMethod({\n        senders: senders,\n        callback: callback,\n        params: [address],\n        method: \"alchemy_getTokenMetadata\"\n      });\n    },\n    getAssetTransfers: function getAssetTransfers(params, callback) {\n      return callAlchemyMethod({\n        senders: senders,\n        callback: callback,\n        params: [__assign(__assign({}, params), {\n          maxCount: params.maxCount != null ? toHex(params.maxCount) : undefined\n        })],\n        method: \"alchemy_getAssetTransfers\"\n      });\n    }\n  };\n  patchSubscriptions(alchemyWeb3);\n  return alchemyWeb3;\n}\n\nfunction fillInConfigDefaults(_a) {\n  var _b = _a === void 0 ? {} : _a,\n      _c = _b.writeProvider,\n      writeProvider = _c === void 0 ? getWindowProvider() : _c,\n      _d = _b.maxRetries,\n      maxRetries = _d === void 0 ? DEFAULT_MAX_RETRIES : _d,\n      _e = _b.retryInterval,\n      retryInterval = _e === void 0 ? DEFAULT_RETRY_INTERVAL : _e,\n      _f = _b.retryJitter,\n      retryJitter = _f === void 0 ? DEFAULT_RETRY_JITTER : _f;\n\n  return {\n    writeProvider: writeProvider,\n    maxRetries: maxRetries,\n    retryInterval: retryInterval,\n    retryJitter: retryJitter\n  };\n}\n\nfunction getWindowProvider() {\n  return typeof window !== \"undefined\" ? window.ethereum : null;\n}\n\nfunction callAlchemyMethod(_a) {\n  var _this = this;\n\n  var senders = _a.senders,\n      method = _a.method,\n      params = _a.params,\n      _b = _a.callback,\n      callback = _b === void 0 ? noop : _b,\n      _c = _a.processResponse,\n      processResponse = _c === void 0 ? identity : _c;\n\n  var promise = function () {\n    return __awaiter(_this, void 0, void 0, function () {\n      var result;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , senders.send(method, params)];\n\n          case 1:\n            result = _a.sent();\n            return [2\n            /*return*/\n            , processResponse(result)];\n        }\n      });\n    });\n  }();\n\n  callWhenDone(promise, callback);\n  return promise;\n}\n\nfunction processTokenBalanceResponse(rawResponse) {\n  // Convert token balance fields from hex-string to decimal-string.\n  var fixedTokenBalances = rawResponse.tokenBalances.map(function (balance) {\n    return balance.tokenBalance != null ? __assign(__assign({}, balance), {\n      tokenBalance: hexToNumberString(balance.tokenBalance)\n    }) : balance;\n  });\n  return __assign(__assign({}, rawResponse), {\n    tokenBalances: fixedTokenBalances\n  });\n}\n/**\n * Updates Web3's internal subscription architecture to also handle Alchemy\n * specific subscriptions.\n */\n\n\nfunction patchSubscriptions(web3) {\n  var eth = web3.eth;\n  var oldSubscribe = eth.subscribe.bind(eth);\n\n  eth.subscribe = function (type) {\n    var rest = [];\n\n    for (var _i = 1; _i < arguments.length; _i++) {\n      rest[_i - 1] = arguments[_i];\n    }\n\n    if (type === \"alchemy_fullPendingTransactions\" || type === \"alchemy_newFullPendingTransactions\") {\n      return suppressNoSubscriptionExistsWarning(function () {\n        return oldSubscribe.apply(void 0, __spread([\"alchemy_newFullPendingTransactions\"], rest));\n      });\n    }\n\n    return oldSubscribe.apply(void 0, __spread([type], rest));\n  };\n}\n/**\n * VERY hacky wrapper to suppress a spurious warning when subscribing to an\n * Alchemy subscription that isn't built into Web3.\n */\n\n\nfunction suppressNoSubscriptionExistsWarning(f) {\n  var oldConsoleWarn = console.warn;\n\n  console.warn = function () {\n    var args = [];\n\n    for (var _i = 0; _i < arguments.length; _i++) {\n      args[_i] = arguments[_i];\n    }\n\n    if (typeof args[0] === \"string\" && args[0].includes(\" doesn't exist. Subscribing anyway.\")) {\n      return;\n    }\n\n    return oldConsoleWarn.apply(console, args);\n  };\n\n  try {\n    return f();\n  } finally {\n    console.warn = oldConsoleWarn;\n  }\n}\n\nfunction noop() {// Nothing.\n}\n\nfunction identity(x) {\n  return x;\n}","map":{"version":3,"mappings":"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","names":["Web3","hexToNumberString","toHex","callWhenDone","makeAlchemyContext","DEFAULT_MAX_RETRIES","DEFAULT_RETRY_INTERVAL","DEFAULT_RETRY_JITTER","AssetTransfersCategory","createAlchemyWeb3","alchemyUrl","config","fullConfig","fillInConfigDefaults","provider","senders","setWriteProvider","alchemyWeb3","setProvider","Error","alchemy","getTokenAllowance","params","callback","method","getTokenBalances","address","contractAddresses","processResponse","processTokenBalanceResponse","getTokenMetadata","getAssetTransfers","maxCount","undefined","patchSubscriptions","_a","_b","_c","writeProvider","getWindowProvider","_d","maxRetries","_e","retryInterval","_f","retryJitter","window","ethereum","callAlchemyMethod","noop","identity","promise","send","result","rawResponse","fixedTokenBalances","tokenBalances","map","balance","tokenBalance","__assign","web3","oldSubscribe","eth","subscribe","bind","type","rest","suppressNoSubscriptionExistsWarning","__spread","f","oldConsoleWarn","console","warn","args","includes","apply","x"],"sourceRoot":"","sources":["../../src/index.ts"],"sourcesContent":["import Web3 from \"web3\";\nimport { Log, LogsOptions, Transaction } from \"web3-core\";\nimport { Subscription } from \"web3-core-subscriptions\";\nimport { BlockHeader, Eth, Syncing } from \"web3-eth\";\nimport { hexToNumberString, toHex } from \"web3-utils\";\nimport { AlchemyWeb3Config, FullConfig, Provider, Web3Callback } from \"./types\";\nimport { JsonRpcSenders } from \"./util/jsonRpc\";\nimport { callWhenDone } from \"./util/promises\";\nimport { makeAlchemyContext } from \"./web3-adapter/alchemyContext\";\n\nconst DEFAULT_MAX_RETRIES = 3;\nconst DEFAULT_RETRY_INTERVAL = 1000;\nconst DEFAULT_RETRY_JITTER = 250;\n\nexport interface AlchemyWeb3 extends Web3 {\n  alchemy: AlchemyMethods;\n  eth: AlchemyEth;\n  setWriteProvider(provider: Provider | null | undefined): void;\n}\n\nexport interface AlchemyMethods {\n  getTokenAllowance(\n    params: TokenAllowanceParams,\n    callback?: Web3Callback<TokenAllowanceResponse>,\n  ): Promise<TokenAllowanceResponse>;\n  getTokenBalances(\n    address: string,\n    contractAddresses: string[],\n    callback?: Web3Callback<TokenBalancesResponse>,\n  ): Promise<TokenBalancesResponse>;\n  getTokenMetadata(\n    address: string,\n    callback?: Web3Callback<TokenMetadataResponse>,\n  ): Promise<TokenMetadataResponse>;\n  getAssetTransfers(\n    params: AssetTransfersParams,\n    callback?: Web3Callback<AssetTransfersResponse>,\n  ): Promise<AssetTransfersResponse>;\n}\n\nexport interface TokenAllowanceParams {\n  contract: string;\n  owner: string;\n  spender: string;\n}\n\nexport type TokenAllowanceResponse = string;\n\nexport interface TokenBalancesResponse {\n  address: string;\n  tokenBalances: TokenBalance[];\n}\n\nexport type TokenBalance = TokenBalanceSuccess | TokenBalanceFailure;\n\nexport interface TokenBalanceSuccess {\n  address: string;\n  tokenBalance: string;\n  error: null;\n}\n\nexport interface TokenBalanceFailure {\n  address: string;\n  tokenBalance: null;\n  error: string;\n}\n\nexport interface TokenMetadataResponse {\n  decimals: number | null;\n  logo: string | null;\n  name: string | null;\n  symbol: string | null;\n}\n\nexport interface AssetTransfersParams {\n  fromBlock?: string;\n  toBlock?: string;\n  fromAddress?: string;\n  toAddress?: string;\n  contractAddresses?: string[];\n  excludeZeroValue?: boolean;\n  maxCount?: number;\n  category?: AssetTransfersCategory[];\n  pageKey?: string;\n}\n\nexport enum AssetTransfersCategory {\n  EXTERNAL = \"external\",\n  INTERNAL = \"internal\",\n  TOKEN = \"token\",\n}\n\nexport interface AssetTransfersResponse {\n  transfers: AssetTransfersResult[];\n  pageKey?: string;\n}\n\nexport interface AssetTransfersResult {\n  category: AssetTransfersCategory;\n  blockNum: string;\n  from: string;\n  to: string | null;\n  value: number | null;\n  erc721TokenId: string | null;\n  asset: string | null;\n  hash: string;\n  rawContract: RawContract;\n}\n\nexport interface RawContract {\n  value: string | null;\n  address: string | null;\n  decimal: string | null;\n}\n\n/**\n * Same as Eth, but with `subscribe` allowing more types.\n */\nexport interface AlchemyEth extends Eth {\n  subscribe(\n    type: \"logs\",\n    options?: LogsOptions,\n    callback?: (error: Error, log: Log) => void,\n  ): Subscription<Log>;\n  subscribe(\n    type: \"syncing\",\n    callback?: (error: Error, result: Syncing) => void,\n  ): Subscription<Syncing>;\n  subscribe(\n    type: \"newBlockHeaders\",\n    callback?: (error: Error, blockHeader: BlockHeader) => void,\n  ): Subscription<BlockHeader>;\n  subscribe(\n    type: \"pendingTransactions\",\n    callback?: (error: Error, transactionHash: string) => void,\n  ): Subscription<string>;\n  subscribe(\n    type: \"alchemy_fullPendingTransactions\",\n    callback?: (error: Error, transaction: Transaction) => void,\n  ): Subscription<Transaction>;\n  subscribe(\n    type:\n      | \"pendingTransactions\"\n      | \"logs\"\n      | \"syncing\"\n      | \"newBlockHeaders\"\n      | \"alchemy_fullPendingTransactions\",\n    options?: null | LogsOptions,\n    callback?: (\n      error: Error,\n      item: Log | Syncing | BlockHeader | string | Transaction,\n    ) => void,\n  ): Subscription<Log | BlockHeader | Syncing | string>;\n}\n\ninterface EthereumWindow extends Window {\n  ethereum?: any;\n}\n\ndeclare const window: EthereumWindow;\n\nexport function createAlchemyWeb3(\n  alchemyUrl: string,\n  config?: AlchemyWeb3Config,\n): AlchemyWeb3 {\n  const fullConfig = fillInConfigDefaults(config);\n  const { provider, senders, setWriteProvider } = makeAlchemyContext(\n    alchemyUrl,\n    fullConfig,\n  );\n  const alchemyWeb3 = new Web3(provider) as AlchemyWeb3;\n  alchemyWeb3.setProvider = () => {\n    throw new Error(\n      \"setProvider is not supported in Alchemy Web3. To change the provider used for writes, use setWriteProvider() instead.\",\n    );\n  };\n  alchemyWeb3.setWriteProvider = setWriteProvider;\n  alchemyWeb3.alchemy = {\n    getTokenAllowance: (params: TokenAllowanceParams, callback) =>\n      callAlchemyMethod({\n        senders,\n        callback,\n        method: \"alchemy_getTokenAllowance\",\n        params: [params],\n      }),\n    getTokenBalances: (address, contractAddresses, callback) =>\n      callAlchemyMethod({\n        senders,\n        callback,\n        method: \"alchemy_getTokenBalances\",\n        params: [address, contractAddresses],\n        processResponse: processTokenBalanceResponse,\n      }),\n    getTokenMetadata: (address, callback) =>\n      callAlchemyMethod({\n        senders,\n        callback,\n        params: [address],\n        method: \"alchemy_getTokenMetadata\",\n      }),\n    getAssetTransfers: (params: AssetTransfersParams, callback) =>\n      callAlchemyMethod({\n        senders,\n        callback,\n        params: [\n          {\n            ...params,\n            maxCount:\n              params.maxCount != null ? toHex(params.maxCount) : undefined,\n          },\n        ],\n        method: \"alchemy_getAssetTransfers\",\n      }),\n  };\n  patchSubscriptions(alchemyWeb3);\n  return alchemyWeb3;\n}\n\nfunction fillInConfigDefaults({\n  writeProvider = getWindowProvider(),\n  maxRetries = DEFAULT_MAX_RETRIES,\n  retryInterval = DEFAULT_RETRY_INTERVAL,\n  retryJitter = DEFAULT_RETRY_JITTER,\n}: AlchemyWeb3Config = {}): FullConfig {\n  return { writeProvider, maxRetries, retryInterval, retryJitter };\n}\n\nfunction getWindowProvider(): Provider | null {\n  return typeof window !== \"undefined\" ? window.ethereum : null;\n}\n\ninterface CallAlchemyMethodParams<T> {\n  senders: JsonRpcSenders;\n  method: string;\n  params: any[];\n  callback?: Web3Callback<T>;\n  processResponse?(response: any): T;\n}\n\nfunction callAlchemyMethod<T>({\n  senders,\n  method,\n  params,\n  callback = noop,\n  processResponse = identity,\n}: CallAlchemyMethodParams<T>): Promise<T> {\n  const promise = (async () => {\n    const result = await senders.send(method, params);\n    return processResponse(result);\n  })();\n  callWhenDone(promise, callback);\n  return promise;\n}\n\nfunction processTokenBalanceResponse(\n  rawResponse: TokenBalancesResponse,\n): TokenBalancesResponse {\n  // Convert token balance fields from hex-string to decimal-string.\n  const fixedTokenBalances = rawResponse.tokenBalances.map((balance) =>\n    balance.tokenBalance != null\n      ? { ...balance, tokenBalance: hexToNumberString(balance.tokenBalance) }\n      : balance,\n  );\n  return { ...rawResponse, tokenBalances: fixedTokenBalances };\n}\n\n/**\n * Updates Web3's internal subscription architecture to also handle Alchemy\n * specific subscriptions.\n */\nfunction patchSubscriptions(web3: Web3): void {\n  const { eth } = web3;\n  const oldSubscribe = eth.subscribe.bind(eth);\n  eth.subscribe = ((type: string, ...rest: any[]) => {\n    if (\n      type === \"alchemy_fullPendingTransactions\" ||\n      type === \"alchemy_newFullPendingTransactions\"\n    ) {\n      return suppressNoSubscriptionExistsWarning(() =>\n        oldSubscribe(\"alchemy_newFullPendingTransactions\" as any, ...rest),\n      );\n    }\n    return oldSubscribe(type as any, ...rest);\n  }) as any;\n}\n\n/**\n * VERY hacky wrapper to suppress a spurious warning when subscribing to an\n * Alchemy subscription that isn't built into Web3.\n */\nfunction suppressNoSubscriptionExistsWarning<T>(f: () => T): T {\n  const oldConsoleWarn = console.warn;\n  console.warn = (...args: unknown[]) => {\n    if (\n      typeof args[0] === \"string\" &&\n      args[0].includes(\" doesn't exist. Subscribing anyway.\")\n    ) {\n      return;\n    }\n    return oldConsoleWarn.apply(console, args);\n  };\n  try {\n    return f();\n  } finally {\n    console.warn = oldConsoleWarn;\n  }\n}\n\nfunction noop(): void {\n  // Nothing.\n}\n\nfunction identity<T>(x: T): T {\n  return x;\n}\n"]},"metadata":{},"sourceType":"module"}