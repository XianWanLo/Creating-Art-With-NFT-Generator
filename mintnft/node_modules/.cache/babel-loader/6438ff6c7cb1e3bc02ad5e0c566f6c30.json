{"ast":null,"code":"import { __read, __spread, __values } from \"tslib\";\nimport { isResponse } from \"../types\";\nexport function makeWebSocketSender(ws) {\n  var contextsById = new Map();\n  ws.addEventListener(\"message\", function (message) {\n    var response = JSON.parse(message.data);\n\n    if (!isResponse(response)) {\n      return;\n    }\n\n    var id = getIdFromResponse(response);\n\n    if (id === undefined) {\n      return;\n    }\n\n    var context = contextsById.get(id);\n\n    if (!context) {\n      return;\n    }\n\n    var resolve = context.resolve;\n    contextsById.delete(id);\n\n    if (!Array.isArray(response) && response.error && response.error.code === 429) {\n      resolve({\n        type: \"rateLimit\"\n      });\n    } else {\n      resolve({\n        response: response,\n        type: \"jsonrpc\"\n      });\n    }\n  });\n  ws.addEventListener(\"down\", function () {\n    __spread(contextsById).forEach(function (_a) {\n      var _b = __read(_a, 2),\n          id = _b[0],\n          _c = _b[1],\n          request = _c.request,\n          resolve = _c.resolve;\n\n      if (isWrite(request)) {\n        // Writes cannot be resent because they will fail for a duplicate nonce.\n        contextsById.delete(id);\n        resolve({\n          type: \"networkError\",\n          status: 0,\n          message: \"WebSocket closed before receiving a response for write request with id: \" + id + \".\"\n        });\n      }\n    });\n  });\n  ws.addEventListener(\"reopen\", function () {\n    var e_1, _a;\n\n    try {\n      for (var _b = __values(contextsById.values()), _c = _b.next(); !_c.done; _c = _b.next()) {\n        var request = _c.value.request;\n        ws.send(JSON.stringify(request));\n      }\n    } catch (e_1_1) {\n      e_1 = {\n        error: e_1_1\n      };\n    } finally {\n      try {\n        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);\n      } finally {\n        if (e_1) throw e_1.error;\n      }\n    }\n  });\n  return function (request) {\n    return new Promise(function (resolve) {\n      var id = getIdFromRequest(request);\n\n      if (id !== undefined) {\n        var existingContext = contextsById.get(id);\n\n        if (existingContext) {\n          var message = \"Another WebSocket request was made with the same id (\" + id + \") before a response was received.\";\n          console.error(message);\n          existingContext.resolve({\n            message: message,\n            type: \"networkError\",\n            status: 0\n          });\n        }\n\n        contextsById.set(id, {\n          request: request,\n          resolve: resolve\n        });\n      }\n\n      ws.send(JSON.stringify(request));\n    });\n  };\n}\n\nfunction getIdFromRequest(request) {\n  if (!Array.isArray(request)) {\n    return request.id;\n  }\n\n  return getCanonicalIdFromList(request.map(function (p) {\n    return p.id;\n  }));\n}\n\nfunction getIdFromResponse(response) {\n  if (!Array.isArray(response)) {\n    return response.id;\n  }\n\n  return getCanonicalIdFromList(response.map(function (p) {\n    return p.id;\n  }));\n}\n/**\n * Since the JSON-RPC spec allows responses to be returned in a different order\n * than sent, we need a mechanism for choosing a canonical id from a list that\n * doesn't depend on the order. This chooses the \"minimum\" id by an arbitrary\n * ordering: the smallest string if possible, otherwise the smallest number,\n * otherwise null.\n */\n\n\nfunction getCanonicalIdFromList(ids) {\n  var stringIds = ids.filter(function (id) {\n    return typeof id === \"string\";\n  });\n\n  if (stringIds.length > 0) {\n    return stringIds.reduce(function (bestId, id) {\n      return bestId < id ? bestId : id;\n    });\n  }\n\n  var numberIds = ids.filter(function (id) {\n    return typeof id === \"number\";\n  });\n\n  if (numberIds.length > 0) {\n    return Math.min.apply(Math, __spread(numberIds));\n  }\n\n  return ids.indexOf(null) >= 0 ? null : undefined;\n}\n\nfunction isWrite(request) {\n  return Array.isArray(request) ? request.every(isSingleWrite) : isSingleWrite(request);\n}\n\nvar WRITE_METHODS = [\"eth_sendTransaction\", \"eth_sendRawTransaction\"];\n\nfunction isSingleWrite(request) {\n  return WRITE_METHODS.includes(request.method);\n}","map":{"version":3,"sources":["../../../src/web3-adapter/alchemySendWebSocket.ts"],"names":[],"mappings":"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","sourcesContent":["import SturdyWebSocket from \"sturdy-websocket\";\nimport {\n  isResponse,\n  JsonRpcId,\n  JsonRpcRequest,\n  SingleOrBatchRequest,\n  SingleOrBatchResponse,\n  WebSocketMessage,\n} from \"../types\";\nimport { AlchemySendFunction, AlchemySendResult } from \"./alchemySend\";\n\ninterface RequestContext {\n  request: SingleOrBatchRequest;\n  resolve(response: AlchemySendResult): void;\n}\n\nexport function makeWebSocketSender(ws: SturdyWebSocket): AlchemySendFunction {\n  const contextsById = new Map<JsonRpcId, RequestContext>();\n  ws.addEventListener(\"message\", message => {\n    const response: WebSocketMessage = JSON.parse(message.data);\n    if (!isResponse(response)) {\n      return;\n    }\n    const id = getIdFromResponse(response);\n    if (id === undefined) {\n      return;\n    }\n    const context = contextsById.get(id);\n    if (!context) {\n      return;\n    }\n    const { resolve } = context;\n    contextsById.delete(id);\n    if (\n      !Array.isArray(response) &&\n      response.error &&\n      response.error.code === 429\n    ) {\n      resolve({ type: \"rateLimit\" });\n    } else {\n      resolve({ response, type: \"jsonrpc\" });\n    }\n  });\n  ws.addEventListener(\"down\", () => {\n    [...contextsById].forEach(([id, { request, resolve }]) => {\n      if (isWrite(request)) {\n        // Writes cannot be resent because they will fail for a duplicate nonce.\n        contextsById.delete(id);\n        resolve({\n          type: \"networkError\",\n          status: 0,\n          message: `WebSocket closed before receiving a response for write request with id: ${id}.`,\n        });\n      }\n    });\n  });\n  ws.addEventListener(\"reopen\", () => {\n    for (const { request } of contextsById.values()) {\n      ws.send(JSON.stringify(request));\n    }\n  });\n\n  return request =>\n    new Promise(resolve => {\n      const id = getIdFromRequest(request);\n      if (id !== undefined) {\n        const existingContext = contextsById.get(id);\n        if (existingContext) {\n          const message = `Another WebSocket request was made with the same id (${id}) before a response was received.`;\n          console.error(message);\n          existingContext.resolve({\n            message,\n            type: \"networkError\",\n            status: 0,\n          });\n        }\n        contextsById.set(id, { request, resolve });\n      }\n      ws.send(JSON.stringify(request));\n    });\n}\n\nfunction getIdFromRequest(\n  request: SingleOrBatchRequest,\n): JsonRpcId | undefined {\n  if (!Array.isArray(request)) {\n    return request.id;\n  }\n  return getCanonicalIdFromList(request.map(p => p.id));\n}\n\nfunction getIdFromResponse(\n  response: SingleOrBatchResponse,\n): JsonRpcId | undefined {\n  if (!Array.isArray(response)) {\n    return response.id;\n  }\n  return getCanonicalIdFromList(response.map(p => p.id));\n}\n\n/**\n * Since the JSON-RPC spec allows responses to be returned in a different order\n * than sent, we need a mechanism for choosing a canonical id from a list that\n * doesn't depend on the order. This chooses the \"minimum\" id by an arbitrary\n * ordering: the smallest string if possible, otherwise the smallest number,\n * otherwise null.\n */\nfunction getCanonicalIdFromList(\n  ids: Array<JsonRpcId | undefined>,\n): JsonRpcId | undefined {\n  const stringIds: string[] = ids.filter(id => typeof id === \"string\") as any;\n  if (stringIds.length > 0) {\n    return stringIds.reduce((bestId, id) => (bestId < id ? bestId : id));\n  }\n  const numberIds: number[] = ids.filter(id => typeof id === \"number\") as any;\n  if (numberIds.length > 0) {\n    return Math.min(...numberIds);\n  }\n  return ids.indexOf(null) >= 0 ? null : undefined;\n}\n\nfunction isWrite(request: SingleOrBatchRequest): boolean {\n  return Array.isArray(request)\n    ? request.every(isSingleWrite)\n    : isSingleWrite(request);\n}\n\nconst WRITE_METHODS = [\"eth_sendTransaction\", \"eth_sendRawTransaction\"];\n\nfunction isSingleWrite(request: JsonRpcRequest): boolean {\n  return WRITE_METHODS.includes(request.method);\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}