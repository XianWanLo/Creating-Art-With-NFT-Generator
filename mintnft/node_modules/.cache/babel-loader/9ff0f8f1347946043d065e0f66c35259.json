{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.importPublic = exports.privateToPublic = exports.privateToAddress = exports.publicToAddress = exports.pubToAddress = exports.isValidPublic = exports.isValidPrivate = exports.isPrecompiled = exports.generateAddress2 = exports.generateAddress = exports.isValidChecksumAddress = exports.toChecksumAddress = exports.isZeroAddress = exports.isValidAddress = exports.zeroAddress = void 0;\n\nvar assert = require('assert');\n\nvar ethjsUtil = require('ethjs-util');\n\nvar secp256k1 = require('./secp256k1v3-adapter');\n\nvar BN = require(\"bn.js\");\n\nvar bytes_1 = require(\"./bytes\");\n\nvar hash_1 = require(\"./hash\");\n/**\n * Returns a zero address.\n */\n\n\nexports.zeroAddress = function () {\n  var addressLength = 20;\n  var addr = bytes_1.zeros(addressLength);\n  return bytes_1.bufferToHex(addr);\n};\n/**\n * Checks if the address is a valid. Accepts checksummed addresses too.\n */\n\n\nexports.isValidAddress = function (address) {\n  return /^0x[0-9a-fA-F]{40}$/.test(address);\n};\n/**\n * Checks if a given address is a zero address.\n */\n\n\nexports.isZeroAddress = function (address) {\n  var zeroAddr = exports.zeroAddress();\n  return zeroAddr === bytes_1.addHexPrefix(address);\n};\n/**\n * Returns a checksummed address.\n *\n * If a eip1191ChainId is provided, the chainId will be included in the checksum calculation. This\n * has the effect of checksummed addresses for one chain having invalid checksums for others.\n * For more details, consult EIP-1191.\n *\n * WARNING: Checksums with and without the chainId will differ. As of 2019-06-26, the most commonly\n * used variation in Ethereum was without the chainId. This may change in the future.\n */\n\n\nexports.toChecksumAddress = function (address, eip1191ChainId) {\n  address = ethjsUtil.stripHexPrefix(address).toLowerCase();\n  var prefix = eip1191ChainId !== undefined ? eip1191ChainId.toString() + '0x' : '';\n  var hash = hash_1.keccak(prefix + address).toString('hex');\n  var ret = '0x';\n\n  for (var i = 0; i < address.length; i++) {\n    if (parseInt(hash[i], 16) >= 8) {\n      ret += address[i].toUpperCase();\n    } else {\n      ret += address[i];\n    }\n  }\n\n  return ret;\n};\n/**\n * Checks if the address is a valid checksummed address.\n *\n * See toChecksumAddress' documentation for details about the eip1191ChainId parameter.\n */\n\n\nexports.isValidChecksumAddress = function (address, eip1191ChainId) {\n  return exports.isValidAddress(address) && exports.toChecksumAddress(address, eip1191ChainId) === address;\n};\n/**\n * Generates an address of a newly created contract.\n * @param from The address which is creating this new address\n * @param nonce The nonce of the from account\n */\n\n\nexports.generateAddress = function (from, nonce) {\n  from = bytes_1.toBuffer(from);\n  var nonceBN = new BN(nonce);\n\n  if (nonceBN.isZero()) {\n    // in RLP we want to encode null in the case of zero nonce\n    // read the RLP documentation for an answer if you dare\n    return hash_1.rlphash([from, null]).slice(-20);\n  } // Only take the lower 160bits of the hash\n\n\n  return hash_1.rlphash([from, Buffer.from(nonceBN.toArray())]).slice(-20);\n};\n/**\n * Generates an address for a contract created using CREATE2.\n * @param from The address which is creating this new address\n * @param salt A salt\n * @param initCode The init code of the contract being created\n */\n\n\nexports.generateAddress2 = function (from, salt, initCode) {\n  var fromBuf = bytes_1.toBuffer(from);\n  var saltBuf = bytes_1.toBuffer(salt);\n  var initCodeBuf = bytes_1.toBuffer(initCode);\n  assert(fromBuf.length === 20);\n  assert(saltBuf.length === 32);\n  var address = hash_1.keccak256(Buffer.concat([Buffer.from('ff', 'hex'), fromBuf, saltBuf, hash_1.keccak256(initCodeBuf)]));\n  return address.slice(-20);\n};\n/**\n * Returns true if the supplied address belongs to a precompiled account (Byzantium).\n */\n\n\nexports.isPrecompiled = function (address) {\n  var a = bytes_1.unpad(address);\n  return a.length === 1 && a[0] >= 1 && a[0] <= 8;\n};\n/**\n * Checks if the private key satisfies the rules of the curve secp256k1.\n */\n\n\nexports.isValidPrivate = function (privateKey) {\n  return secp256k1.privateKeyVerify(privateKey);\n};\n/**\n * Checks if the public key satisfies the rules of the curve secp256k1\n * and the requirements of Ethereum.\n * @param publicKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\n\n\nexports.isValidPublic = function (publicKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n\n  if (publicKey.length === 64) {\n    // Convert to SEC1 for secp256k1\n    return secp256k1.publicKeyVerify(Buffer.concat([Buffer.from([4]), publicKey]));\n  }\n\n  if (!sanitize) {\n    return false;\n  }\n\n  return secp256k1.publicKeyVerify(publicKey);\n};\n/**\n * Returns the ethereum address of a given public key.\n * Accepts \"Ethereum public keys\" and SEC1 encoded keys.\n * @param pubKey The two points of an uncompressed key, unless sanitize is enabled\n * @param sanitize Accept public keys in other formats\n */\n\n\nexports.pubToAddress = function (pubKey, sanitize) {\n  if (sanitize === void 0) {\n    sanitize = false;\n  }\n\n  pubKey = bytes_1.toBuffer(pubKey);\n\n  if (sanitize && pubKey.length !== 64) {\n    pubKey = secp256k1.publicKeyConvert(pubKey, false).slice(1);\n  }\n\n  assert(pubKey.length === 64); // Only take the lower 160bits of the hash\n\n  return hash_1.keccak(pubKey).slice(-20);\n};\n\nexports.publicToAddress = exports.pubToAddress;\n/**\n * Returns the ethereum address of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\n\nexports.privateToAddress = function (privateKey) {\n  return exports.publicToAddress(exports.privateToPublic(privateKey));\n};\n/**\n * Returns the ethereum public key of a given private key.\n * @param privateKey A private key must be 256 bits wide\n */\n\n\nexports.privateToPublic = function (privateKey) {\n  privateKey = bytes_1.toBuffer(privateKey); // skip the type flag and use the X, Y points\n\n  return secp256k1.publicKeyCreate(privateKey, false).slice(1);\n};\n/**\n * Converts a public key to the Ethereum format.\n */\n\n\nexports.importPublic = function (publicKey) {\n  publicKey = bytes_1.toBuffer(publicKey);\n\n  if (publicKey.length !== 64) {\n    publicKey = secp256k1.publicKeyConvert(publicKey, false).slice(1);\n  }\n\n  return publicKey;\n};","map":{"version":3,"mappings":"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","names":["assert","require","ethjsUtil","secp256k1","exports","addressLength","addr","bytes_1","address","test","zeroAddr","eip1191ChainId","stripHexPrefix","toLowerCase","prefix","undefined","toString","hash","hash_1","ret","i","length","parseInt","toUpperCase","from","nonce","nonceBN","BN","isZero","slice","Buffer","toArray","salt","initCode","fromBuf","saltBuf","initCodeBuf","concat","a","privateKey","privateKeyVerify","publicKey","sanitize","publicKeyVerify","pubKey","publicKeyConvert","publicKeyCreate"],"sourceRoot":"","sources":["../src/account.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}