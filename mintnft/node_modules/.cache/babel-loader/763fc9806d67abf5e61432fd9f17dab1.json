{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ecdhUnsafe = exports.ecdh = exports.recover = exports.verify = exports.sign = exports.signatureImportLax = exports.signatureImport = exports.signatureExport = exports.signatureNormalize = exports.publicKeyCombine = exports.publicKeyTweakMul = exports.publicKeyTweakAdd = exports.publicKeyVerify = exports.publicKeyConvert = exports.publicKeyCreate = exports.privateKeyTweakMul = exports.privateKeyTweakAdd = exports.privateKeyModInverse = exports.privateKeyNegate = exports.privateKeyImport = exports.privateKeyExport = exports.privateKeyVerify = void 0;\n\nvar secp256k1 = require('ethereum-cryptography/secp256k1');\n\nvar secp256k1v3 = require('./secp256k1v3-lib/index');\n\nvar der = require('./secp256k1v3-lib/der');\n/**\n * Verify an ECDSA privateKey\n * @method privateKeyVerify\n * @param {Buffer} privateKey\n * @return {boolean}\n */\n\n\nexports.privateKeyVerify = function (privateKey) {\n  // secp256k1 v4 version throws when privateKey length is not 32\n  if (privateKey.length !== 32) {\n    return false;\n  }\n\n  return secp256k1.privateKeyVerify(Uint8Array.from(privateKey));\n};\n/**\n * Export a privateKey in DER format\n * @method privateKeyExport\n * @param {Buffer} privateKey\n * @param {boolean} compressed\n * @return {boolean}\n */\n\n\nexports.privateKeyExport = function (privateKey, compressed) {\n  // secp256k1 v4 version throws when privateKey length is not 32\n  if (privateKey.length !== 32) {\n    throw new RangeError('private key length is invalid');\n  }\n\n  var publicKey = secp256k1v3.privateKeyExport(privateKey, compressed);\n  return der.privateKeyExport(privateKey, publicKey, compressed);\n};\n/**\n * Import a privateKey in DER format\n * @method privateKeyImport\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\n\n\nexports.privateKeyImport = function (privateKey) {\n  // privateKeyImport method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  privateKey = der.privateKeyImport(privateKey);\n\n  if (privateKey !== null && privateKey.length === 32 && exports.privateKeyVerify(privateKey)) {\n    return privateKey;\n  }\n\n  throw new Error(\"couldn't import from DER format\");\n};\n/**\n * Negate a privateKey by subtracting it from the order of the curve's base point\n * @method privateKeyNegate\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\n\n\nexports.privateKeyNegate = function (privateKey) {\n  return Buffer.from(secp256k1.privateKeyNegate(Uint8Array.from(privateKey)));\n};\n/**\n * Compute the inverse of a privateKey (modulo the order of the curve's base point).\n * @method privateKeyModInverse\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\n\n\nexports.privateKeyModInverse = function (privateKey) {\n  if (privateKey.length !== 32) {\n    throw new Error('private key length is invalid');\n  }\n\n  return Buffer.from(secp256k1v3.privateKeyModInverse(Uint8Array.from(privateKey)));\n};\n/**\n * Tweak a privateKey by adding tweak to it.\n * @method privateKeyTweakAdd\n * @param {Buffer} privateKey\n * @param {Buffer} tweak\n * @return {Buffer}\n */\n\n\nexports.privateKeyTweakAdd = function (privateKey, tweak) {\n  return Buffer.from(secp256k1.privateKeyTweakAdd(Uint8Array.from(privateKey), tweak));\n};\n/**\n * Tweak a privateKey by multiplying it by a tweak.\n * @method privateKeyTweakMul\n * @param {Buffer} privateKey\n * @param {Buffer} tweak\n * @return {Buffer}\n */\n\n\nexports.privateKeyTweakMul = function (privateKey, tweak) {\n  return Buffer.from(secp256k1.privateKeyTweakMul(Uint8Array.from(privateKey), Uint8Array.from(tweak)));\n};\n/**\n * Compute the public key for a privateKey.\n * @method publicKeyCreate\n * @param {Buffer} privateKey\n * @param {boolean} compressed\n * @return {Buffer}\n */\n\n\nexports.publicKeyCreate = function (privateKey, compressed) {\n  return Buffer.from(secp256k1.publicKeyCreate(Uint8Array.from(privateKey), compressed));\n};\n/**\n * Convert a publicKey to compressed or uncompressed form.\n * @method publicKeyConvert\n * @param {Buffer} publicKey\n * @param {boolean} compressed\n * @return {Buffer}\n */\n\n\nexports.publicKeyConvert = function (publicKey, compressed) {\n  return Buffer.from(secp256k1.publicKeyConvert(Uint8Array.from(publicKey), compressed));\n};\n/**\n * Verify an ECDSA publicKey.\n * @method publicKeyVerify\n * @param {Buffer} publicKey\n * @return {boolean}\n */\n\n\nexports.publicKeyVerify = function (publicKey) {\n  // secp256k1 v4 version throws when publicKey length is not 33 or 65\n  if (publicKey.length !== 33 && publicKey.length !== 65) {\n    return false;\n  }\n\n  return secp256k1.publicKeyVerify(Uint8Array.from(publicKey));\n};\n/**\n * Tweak a publicKey by adding tweak times the generator to it.\n * @method publicKeyTweakAdd\n * @param {Buffer} publicKey\n * @param {Buffer} tweak\n * @param {boolean} compressed\n * @return {Buffer}\n */\n\n\nexports.publicKeyTweakAdd = function (publicKey, tweak, compressed) {\n  return Buffer.from(secp256k1.publicKeyTweakAdd(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\n};\n/**\n * Tweak a publicKey by multiplying it by a tweak value\n * @method publicKeyTweakMul\n * @param {Buffer} publicKey\n * @param {Buffer} tweak\n * @param {boolean} compressed\n * @return {Buffer}\n */\n\n\nexports.publicKeyTweakMul = function (publicKey, tweak, compressed) {\n  return Buffer.from(secp256k1.publicKeyTweakMul(Uint8Array.from(publicKey), Uint8Array.from(tweak), compressed));\n};\n/**\n * Add a given publicKeys together.\n * @method publicKeyCombine\n * @param {Array<Buffer>} publicKeys\n * @param {boolean} compressed\n * @return {Buffer}\n */\n\n\nexports.publicKeyCombine = function (publicKeys, compressed) {\n  var keys = [];\n  publicKeys.forEach(function (publicKey) {\n    keys.push(Uint8Array.from(publicKey));\n  });\n  return Buffer.from(secp256k1.publicKeyCombine(keys, compressed));\n};\n/**\n * Convert a signature to a normalized lower-S form.\n * @method signatureNormalize\n * @param {Buffer} signature\n * @return {Buffer}\n */\n\n\nexports.signatureNormalize = function (signature) {\n  return Buffer.from(secp256k1.signatureNormalize(Uint8Array.from(signature)));\n};\n/**\n * Serialize an ECDSA signature in DER format.\n * @method signatureExport\n * @param {Buffer} signature\n * @return {Buffer}\n */\n\n\nexports.signatureExport = function (signature) {\n  return Buffer.from(secp256k1.signatureExport(Uint8Array.from(signature)));\n};\n/**\n * Parse a DER ECDSA signature (follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\n * @method signatureImport\n * @param {Buffer} signature\n * @return {Buffer}\n */\n\n\nexports.signatureImport = function (signature) {\n  return Buffer.from(secp256k1.signatureImport(Uint8Array.from(signature)));\n};\n/**\n * Parse a DER ECDSA signature (not follow by [BIP66](https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki)).\n * @method signatureImportLax\n * @param {Buffer} signature\n * @return {Buffer}\n */\n\n\nexports.signatureImportLax = function (signature) {\n  // signatureImportLax method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  // ensure that signature is greater than 0\n  if (signature.length === 0) {\n    throw new RangeError('signature length is invalid');\n  }\n\n  var sigObj = der.signatureImportLax(signature);\n\n  if (sigObj === null) {\n    throw new Error(\"couldn't parse DER signature\");\n  }\n\n  return secp256k1v3.signatureImport(sigObj);\n};\n/**\n * Create an ECDSA signature. Always return low-S signature.\n * @method sign\n * @param {Buffer} message\n * @param {Buffer} privateKey\n * @param {Object} options\n * @return {Buffer}\n */\n\n\nexports.sign = function (message, privateKey, options) {\n  if (options === null) {\n    throw new TypeError('options should be an Object');\n  }\n\n  var signOptions = undefined;\n\n  if (options) {\n    signOptions = {};\n\n    if (options.data === null) {\n      // validate option.data length\n      throw new TypeError('options.data should be a Buffer');\n    }\n\n    if (options.data) {\n      if (options.data.length != 32) {\n        throw new RangeError('options.data length is invalid');\n      }\n\n      signOptions.data = new Uint8Array(options.data);\n    }\n\n    if (options.noncefn === null) {\n      throw new TypeError('options.noncefn should be a Function');\n    }\n\n    if (options.noncefn) {\n      // convert option.noncefn function signature\n      signOptions.noncefn = function (message, privateKey, algo, data, attempt) {\n        var bufferAlgo = algo != null ? Buffer.from(algo) : null;\n        var bufferData = data != null ? Buffer.from(data) : null;\n        var buffer = Buffer.from('');\n\n        if (options.noncefn) {\n          buffer = options.noncefn(Buffer.from(message), Buffer.from(privateKey), bufferAlgo, bufferData, attempt);\n        }\n\n        return new Uint8Array(buffer);\n      };\n    }\n  }\n\n  var sig = secp256k1.ecdsaSign(Uint8Array.from(message), Uint8Array.from(privateKey), signOptions);\n  return {\n    signature: Buffer.from(sig.signature),\n    recovery: sig.recid\n  };\n};\n/**\n * Verify an ECDSA signature.\n * @method verify\n * @param {Buffer} message\n * @param {Buffer} signature\n * @param {Buffer} publicKey\n * @return {boolean}\n */\n\n\nexports.verify = function (message, signature, publicKey) {\n  return secp256k1.ecdsaVerify(Uint8Array.from(signature), Uint8Array.from(message), publicKey);\n};\n/**\n * Recover an ECDSA public key from a signature.\n * @method recover\n * @param {Buffer} message\n * @param {Buffer} signature\n * @param {Number} recid\n * @param {boolean} compressed\n * @return {Buffer}\n */\n\n\nexports.recover = function (message, signature, recid, compressed) {\n  return Buffer.from(secp256k1.ecdsaRecover(Uint8Array.from(signature), recid, Uint8Array.from(message), compressed));\n};\n/**\n * Compute an EC Diffie-Hellman secret and applied sha256 to compressed public key.\n * @method ecdh\n * @param {Buffer} publicKey\n * @param {Buffer} privateKey\n * @return {Buffer}\n */\n\n\nexports.ecdh = function (publicKey, privateKey) {\n  // note: secp256k1 v3 doesn't allow optional parameter\n  return Buffer.from(secp256k1.ecdh(Uint8Array.from(publicKey), Uint8Array.from(privateKey), {}));\n};\n\nexports.ecdhUnsafe = function (publicKey, privateKey, compressed) {\n  // ecdhUnsafe method is not part of secp256k1 v4 package\n  // this implementation is based on v3\n  // ensure valid publicKey length\n  if (publicKey.length !== 33 && publicKey.length !== 65) {\n    throw new RangeError('public key length is invalid');\n  } // ensure valid privateKey length\n\n\n  if (privateKey.length !== 32) {\n    throw new RangeError('private key length is invalid');\n  }\n\n  return Buffer.from(secp256k1v3.ecdhUnsafe(Uint8Array.from(publicKey), Uint8Array.from(privateKey), compressed));\n};","map":{"version":3,"mappings":";;;;;;;AAAA,IAAMA,SAAS,GAAGC,OAAO,CAAC,iCAAD,CAAzB;;AACA,IAAMC,WAAW,GAAGD,OAAO,CAAC,yBAAD,CAA3B;;AACA,IAAME,GAAG,GAAGF,OAAO,CAAC,uBAAD,CAAnB;AAwBA;;;;;;;;AAMaG,2BAAmB,UAASC,UAAT,EAA2B;EACzD;EACA,IAAIA,UAAU,CAACC,MAAX,KAAsB,EAA1B,EAA8B;IAC5B,OAAO,KAAP;EACD;;EAED,OAAON,SAAS,CAACO,gBAAV,CAA2BC,UAAU,CAACC,IAAX,CAAgBJ,UAAhB,CAA3B,CAAP;AACD,CAPY;AASb;;;;;;;;;AAOaD,2BAAmB,UAASC,UAAT,EAA6BK,UAA7B,EAAiD;EAC/E;EACA,IAAIL,UAAU,CAACC,MAAX,KAAsB,EAA1B,EAA8B;IAC5B,MAAM,IAAIK,UAAJ,CAAe,+BAAf,CAAN;EACD;;EAED,IAAMC,SAAS,GAAGV,WAAW,CAACW,gBAAZ,CAA6BR,UAA7B,EAAyCK,UAAzC,CAAlB;EAEA,OAAOP,GAAG,CAACU,gBAAJ,CAAqBR,UAArB,EAAiCO,SAAjC,EAA4CF,UAA5C,CAAP;AACD,CATY;AAWb;;;;;;;;AAMaN,2BAAmB,UAASC,UAAT,EAA2B;EACzD;EACA;EACAA,UAAU,GAAGF,GAAG,CAACW,gBAAJ,CAAqBT,UAArB,CAAb;;EACA,IAAIA,UAAU,KAAK,IAAf,IAAuBA,UAAU,CAACC,MAAX,KAAsB,EAA7C,IAAmDF,yBAAiBC,UAAjB,CAAvD,EAAqF;IACnF,OAAOA,UAAP;EACD;;EAED,MAAM,IAAIU,KAAJ,CAAU,iCAAV,CAAN;AACD,CATY;AAWb;;;;;;;;AAMaX,2BAAmB,UAASC,UAAT,EAA2B;EACzD,OAAOW,MAAM,CAACP,IAAP,CAAYT,SAAS,CAACiB,gBAAV,CAA2BT,UAAU,CAACC,IAAX,CAAgBJ,UAAhB,CAA3B,CAAZ,CAAP;AACD,CAFY;AAIb;;;;;;;;AAMaD,+BAAuB,UAASC,UAAT,EAA2B;EAC7D,IAAIA,UAAU,CAACC,MAAX,KAAsB,EAA1B,EAA8B;IAC5B,MAAM,IAAIS,KAAJ,CAAU,+BAAV,CAAN;EACD;;EAED,OAAOC,MAAM,CAACP,IAAP,CAAYP,WAAW,CAACgB,oBAAZ,CAAiCV,UAAU,CAACC,IAAX,CAAgBJ,UAAhB,CAAjC,CAAZ,CAAP;AACD,CANY;AAQb;;;;;;;;;AAOaD,6BAAqB,UAASC,UAAT,EAA6Bc,KAA7B,EAA0C;EAC1E,OAAOH,MAAM,CAACP,IAAP,CAAYT,SAAS,CAACoB,kBAAV,CAA6BZ,UAAU,CAACC,IAAX,CAAgBJ,UAAhB,CAA7B,EAA0Dc,KAA1D,CAAZ,CAAP;AACD,CAFY;AAIb;;;;;;;;;AAOaf,6BAAqB,UAASC,UAAT,EAA6Bc,KAA7B,EAA0C;EAC1E,OAAOH,MAAM,CAACP,IAAP,CACLT,SAAS,CAACqB,kBAAV,CAA6Bb,UAAU,CAACC,IAAX,CAAgBJ,UAAhB,CAA7B,EAA0DG,UAAU,CAACC,IAAX,CAAgBU,KAAhB,CAA1D,CADK,CAAP;AAGD,CAJY;AAMb;;;;;;;;;AAOaf,0BAAkB,UAASC,UAAT,EAA6BK,UAA7B,EAAiD;EAC9E,OAAOM,MAAM,CAACP,IAAP,CAAYT,SAAS,CAACsB,eAAV,CAA0Bd,UAAU,CAACC,IAAX,CAAgBJ,UAAhB,CAA1B,EAAuDK,UAAvD,CAAZ,CAAP;AACD,CAFY;AAIb;;;;;;;;;AAOaN,2BAAmB,UAASQ,SAAT,EAA4BF,UAA5B,EAAgD;EAC9E,OAAOM,MAAM,CAACP,IAAP,CAAYT,SAAS,CAACuB,gBAAV,CAA2Bf,UAAU,CAACC,IAAX,CAAgBG,SAAhB,CAA3B,EAAuDF,UAAvD,CAAZ,CAAP;AACD,CAFY;AAIb;;;;;;;;AAMaN,0BAAkB,UAASQ,SAAT,EAA0B;EACvD;EACA,IAAIA,SAAS,CAACN,MAAV,KAAqB,EAArB,IAA2BM,SAAS,CAACN,MAAV,KAAqB,EAApD,EAAwD;IACtD,OAAO,KAAP;EACD;;EAED,OAAON,SAAS,CAACwB,eAAV,CAA0BhB,UAAU,CAACC,IAAX,CAAgBG,SAAhB,CAA1B,CAAP;AACD,CAPY;AASb;;;;;;;;;;AAQaR,4BAAoB,UAC/BQ,SAD+B,EAE/BO,KAF+B,EAG/BT,UAH+B,EAGX;EAEpB,OAAOM,MAAM,CAACP,IAAP,CACLT,SAAS,CAACyB,iBAAV,CAA4BjB,UAAU,CAACC,IAAX,CAAgBG,SAAhB,CAA5B,EAAwDJ,UAAU,CAACC,IAAX,CAAgBU,KAAhB,CAAxD,EAAgFT,UAAhF,CADK,CAAP;AAGD,CARY;AAUb;;;;;;;;;;AAQaN,4BAAoB,UAC/BQ,SAD+B,EAE/BO,KAF+B,EAG/BT,UAH+B,EAGX;EAEpB,OAAOM,MAAM,CAACP,IAAP,CACLT,SAAS,CAAC0B,iBAAV,CAA4BlB,UAAU,CAACC,IAAX,CAAgBG,SAAhB,CAA5B,EAAwDJ,UAAU,CAACC,IAAX,CAAgBU,KAAhB,CAAxD,EAAgFT,UAAhF,CADK,CAAP;AAGD,CARY;AAUb;;;;;;;;;AAOaN,2BAAmB,UAASuB,UAAT,EAA+BjB,UAA/B,EAAmD;EACjF,IAAMkB,IAAI,GAAiB,EAA3B;EACAD,UAAU,CAACE,OAAX,CAAmB,UAACjB,SAAD,EAAkB;IACnCgB,IAAI,CAACE,IAAL,CAAUtB,UAAU,CAACC,IAAX,CAAgBG,SAAhB,CAAV;EACD,CAFD;EAIA,OAAOI,MAAM,CAACP,IAAP,CAAYT,SAAS,CAAC+B,gBAAV,CAA2BH,IAA3B,EAAiClB,UAAjC,CAAZ,CAAP;AACD,CAPY;AASb;;;;;;;;AAMaN,6BAAqB,UAAS4B,SAAT,EAA0B;EAC1D,OAAOhB,MAAM,CAACP,IAAP,CAAYT,SAAS,CAACiC,kBAAV,CAA6BzB,UAAU,CAACC,IAAX,CAAgBuB,SAAhB,CAA7B,CAAZ,CAAP;AACD,CAFY;AAIb;;;;;;;;AAMa5B,0BAAkB,UAAS4B,SAAT,EAA0B;EACvD,OAAOhB,MAAM,CAACP,IAAP,CAAYT,SAAS,CAACkC,eAAV,CAA0B1B,UAAU,CAACC,IAAX,CAAgBuB,SAAhB,CAA1B,CAAZ,CAAP;AACD,CAFY;AAIb;;;;;;;;AAMa5B,0BAAkB,UAAS4B,SAAT,EAA0B;EACvD,OAAOhB,MAAM,CAACP,IAAP,CAAYT,SAAS,CAACmC,eAAV,CAA0B3B,UAAU,CAACC,IAAX,CAAgBuB,SAAhB,CAA1B,CAAZ,CAAP;AACD,CAFY;AAIb;;;;;;;;AAMa5B,6BAAqB,UAAS4B,SAAT,EAA0B;EAC1D;EACA;EACA;EACA,IAAIA,SAAS,CAAC1B,MAAV,KAAqB,CAAzB,EAA4B;IAC1B,MAAM,IAAIK,UAAJ,CAAe,6BAAf,CAAN;EACD;;EAED,IAAMyB,MAAM,GAAGjC,GAAG,CAACkC,kBAAJ,CAAuBL,SAAvB,CAAf;;EACA,IAAII,MAAM,KAAK,IAAf,EAAqB;IACnB,MAAM,IAAIrB,KAAJ,CAAU,8BAAV,CAAN;EACD;;EAED,OAAOb,WAAW,CAACiC,eAAZ,CAA4BC,MAA5B,CAAP;AACD,CAdY;AAgBb;;;;;;;;;;AAQahC,eAAO,UAClBkC,OADkB,EAElBjC,UAFkB,EAGlBkC,OAHkB,EAGG;EAErB,IAAIA,OAAO,KAAK,IAAhB,EAAsB;IACpB,MAAM,IAAIC,SAAJ,CAAc,6BAAd,CAAN;EACD;;EAED,IAAIC,WAAW,GAA8BC,SAA7C;;EAEA,IAAIH,OAAJ,EAAa;IACXE,WAAW,GAAG,EAAd;;IAEA,IAAIF,OAAO,CAACI,IAAR,KAAiB,IAArB,EAA2B;MACzB;MACA,MAAM,IAAIH,SAAJ,CAAc,iCAAd,CAAN;IACD;;IAED,IAAID,OAAO,CAACI,IAAZ,EAAkB;MAChB,IAAIJ,OAAO,CAACI,IAAR,CAAarC,MAAb,IAAuB,EAA3B,EAA+B;QAC7B,MAAM,IAAIK,UAAJ,CAAe,gCAAf,CAAN;MACD;;MAED8B,WAAW,CAACE,IAAZ,GAAmB,IAAInC,UAAJ,CAAe+B,OAAO,CAACI,IAAvB,CAAnB;IACD;;IAED,IAAIJ,OAAO,CAACK,OAAR,KAAoB,IAAxB,EAA8B;MAC5B,MAAM,IAAIJ,SAAJ,CAAc,sCAAd,CAAN;IACD;;IAED,IAAID,OAAO,CAACK,OAAZ,EAAqB;MACnB;MACAH,WAAW,CAACG,OAAZ,GAAsB,UACpBN,OADoB,EAEpBjC,UAFoB,EAGpBwC,IAHoB,EAIpBF,IAJoB,EAKpBG,OALoB,EAKL;QAEf,IAAMC,UAAU,GAAkBF,IAAI,IAAI,IAAR,GAAe7B,MAAM,CAACP,IAAP,CAAYoC,IAAZ,CAAf,GAAmC,IAArE;QACA,IAAMG,UAAU,GAAkBL,IAAI,IAAI,IAAR,GAAe3B,MAAM,CAACP,IAAP,CAAYkC,IAAZ,CAAf,GAAmC,IAArE;QAEA,IAAIM,MAAM,GAAWjC,MAAM,CAACP,IAAP,CAAY,EAAZ,CAArB;;QAEA,IAAI8B,OAAO,CAACK,OAAZ,EAAqB;UACnBK,MAAM,GAAGV,OAAO,CAACK,OAAR,CACP5B,MAAM,CAACP,IAAP,CAAY6B,OAAZ,CADO,EAEPtB,MAAM,CAACP,IAAP,CAAYJ,UAAZ,CAFO,EAGP0C,UAHO,EAIPC,UAJO,EAKPF,OALO,CAAT;QAOD;;QAED,OAAO,IAAItC,UAAJ,CAAeyC,MAAf,CAAP;MACD,CAvBD;IAwBD;EACF;;EAED,IAAMC,GAAG,GAAGlD,SAAS,CAACmD,SAAV,CACV3C,UAAU,CAACC,IAAX,CAAgB6B,OAAhB,CADU,EAEV9B,UAAU,CAACC,IAAX,CAAgBJ,UAAhB,CAFU,EAGVoC,WAHU,CAAZ;EAMA,OAAO;IACLT,SAAS,EAAEhB,MAAM,CAACP,IAAP,CAAYyC,GAAG,CAAClB,SAAhB,CADN;IAELoB,QAAQ,EAAEF,GAAG,CAACG;EAFT,CAAP;AAID,CAtEY;AAwEb;;;;;;;;;;AAQajD,iBAAS,UAASkC,OAAT,EAA0BN,SAA1B,EAA6CpB,SAA7C,EAA8D;EAClF,OAAOZ,SAAS,CAACsD,WAAV,CAAsB9C,UAAU,CAACC,IAAX,CAAgBuB,SAAhB,CAAtB,EAAkDxB,UAAU,CAACC,IAAX,CAAgB6B,OAAhB,CAAlD,EAA4E1B,SAA5E,CAAP;AACD,CAFY;AAIb;;;;;;;;;;;AASaR,kBAAU,UACrBkC,OADqB,EAErBN,SAFqB,EAGrBqB,KAHqB,EAIrB3C,UAJqB,EAID;EAEpB,OAAOM,MAAM,CAACP,IAAP,CACLT,SAAS,CAACuD,YAAV,CAAuB/C,UAAU,CAACC,IAAX,CAAgBuB,SAAhB,CAAvB,EAAmDqB,KAAnD,EAA0D7C,UAAU,CAACC,IAAX,CAAgB6B,OAAhB,CAA1D,EAAoF5B,UAApF,CADK,CAAP;AAGD,CATY;AAWb;;;;;;;;;AAOaN,eAAO,UAASQ,SAAT,EAA4BP,UAA5B,EAA8C;EAChE;EACA,OAAOW,MAAM,CAACP,IAAP,CAAYT,SAAS,CAACwD,IAAV,CAAehD,UAAU,CAACC,IAAX,CAAgBG,SAAhB,CAAf,EAA2CJ,UAAU,CAACC,IAAX,CAAgBJ,UAAhB,CAA3C,EAAwE,EAAxE,CAAZ,CAAP;AACD,CAHY;;AAKAD,qBAAa,UACxBQ,SADwB,EAExBP,UAFwB,EAGxBK,UAHwB,EAGJ;EAEpB;EACA;EACA;EACA,IAAIE,SAAS,CAACN,MAAV,KAAqB,EAArB,IAA2BM,SAAS,CAACN,MAAV,KAAqB,EAApD,EAAwD;IACtD,MAAM,IAAIK,UAAJ,CAAe,8BAAf,CAAN;EACD,CAPmB,CASpB;;;EACA,IAAIN,UAAU,CAACC,MAAX,KAAsB,EAA1B,EAA8B;IAC5B,MAAM,IAAIK,UAAJ,CAAe,+BAAf,CAAN;EACD;;EAED,OAAOK,MAAM,CAACP,IAAP,CACLP,WAAW,CAACuD,UAAZ,CAAuBjD,UAAU,CAACC,IAAX,CAAgBG,SAAhB,CAAvB,EAAmDJ,UAAU,CAACC,IAAX,CAAgBJ,UAAhB,CAAnD,EAAgFK,UAAhF,CADK,CAAP;AAGD,CApBY","names":["secp256k1","require","secp256k1v3","der","exports","privateKey","length","privateKeyVerify","Uint8Array","from","compressed","RangeError","publicKey","privateKeyExport","privateKeyImport","Error","Buffer","privateKeyNegate","privateKeyModInverse","tweak","privateKeyTweakAdd","privateKeyTweakMul","publicKeyCreate","publicKeyConvert","publicKeyVerify","publicKeyTweakAdd","publicKeyTweakMul","publicKeys","keys","forEach","push","publicKeyCombine","signature","signatureNormalize","signatureExport","signatureImport","sigObj","signatureImportLax","message","options","TypeError","signOptions","undefined","data","noncefn","algo","attempt","bufferAlgo","bufferData","buffer","sig","ecdsaSign","recovery","recid","ecdsaVerify","ecdsaRecover","ecdh","ecdhUnsafe"],"sourceRoot":"","sources":["../src/secp256k1v3-adapter.ts"],"sourcesContent":[null]},"metadata":{},"sourceType":"script"}