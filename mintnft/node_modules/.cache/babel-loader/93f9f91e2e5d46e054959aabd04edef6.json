{"ast":null,"code":"import { __awaiter, __generator } from \"tslib\";\nimport assertNever from \"assert-never\";\nimport { delay, promisify } from \"../util/promises\";\nvar ALCHEMY_DISALLOWED_METHODS = [\"eth_accounts\", \"eth_sendTransaction\", \"eth_sign\", \"eth_signTypedData_v3\", \"eth_signTypedData\", \"personal_sign\"];\nexport function makePayloadSender(alchemySend, config, makePayload) {\n  var currentWriteProvider = getEip1193Provider(config.writeProvider, makePayload);\n\n  var sendPayload = function sendPayload(payload) {\n    var disallowedMethod = getDisallowedMethod(payload);\n\n    if (!disallowedMethod) {\n      try {\n        return sendWithRetries(payload, alchemySend, config);\n      } catch (alchemyError) {\n        // Fallback to write provider, but if both fail throw the error from\n        // Alchemy.\n        if (!currentWriteProvider) {\n          throw alchemyError;\n        }\n\n        try {\n          return sendWithProvider(currentWriteProvider, payload);\n        } catch (_a) {\n          throw alchemyError;\n        }\n      }\n    } else {\n      if (!currentWriteProvider) {\n        throw new Error(\"No provider available for method \\\"\" + disallowedMethod + \"\\\"\");\n      }\n\n      return sendWithProvider(currentWriteProvider, payload);\n    }\n  };\n\n  function setWriteProvider(writeProvider) {\n    currentWriteProvider = getEip1193Provider(writeProvider, makePayload);\n  }\n\n  return {\n    sendPayload: sendPayload,\n    setWriteProvider: setWriteProvider\n  };\n}\n\nfunction getEip1193Provider(provider, makePayload) {\n  if (!provider) {\n    return undefined;\n  }\n\n  var anyProvider = provider;\n  var sendMethod = (anyProvider.sendAsync ? anyProvider.sendAsync : anyProvider.send).bind(anyProvider);\n  return {\n    send: function send(method, params) {\n      return promisify(function (callback) {\n        return sendMethod(makePayload(method, params), callback);\n      });\n    }\n  };\n}\n\nfunction sendWithProvider(provider, payload) {\n  if (!Array.isArray(payload)) {\n    var method = payload.method,\n        params = payload.params;\n    return provider.send(method, params);\n  } else {\n    // These providers don't support batches, sadly.\n    return Promise.all(payload.map(function (_a) {\n      var method = _a.method,\n          params = _a.params;\n      return provider.send(method, params);\n    }));\n  }\n}\n\nfunction getDisallowedMethod(payload) {\n  var payloads = Array.isArray(payload) ? payload : [payload];\n  var disallowedRequest = payloads.find(function (p) {\n    return ALCHEMY_DISALLOWED_METHODS.indexOf(p.method) >= 0;\n  }) || undefined;\n  return disallowedRequest && disallowedRequest.method;\n}\n\nfunction sendWithRetries(payload, alchemySend, _a) {\n  var maxRetries = _a.maxRetries,\n      retryInterval = _a.retryInterval,\n      retryJitter = _a.retryJitter;\n  return __awaiter(this, void 0, void 0, function () {\n    var i, result, status_1, message, statusString;\n    return __generator(this, function (_b) {\n      switch (_b.label) {\n        case 0:\n          i = 0;\n          _b.label = 1;\n\n        case 1:\n          if (!(i < maxRetries + 1)) return [3\n          /*break*/\n          , 5];\n          return [4\n          /*yield*/\n          , alchemySend(payload)];\n\n        case 2:\n          result = _b.sent();\n\n          switch (result.type) {\n            case \"jsonrpc\":\n              return [2\n              /*return*/\n              , result.response];\n\n            case \"rateLimit\":\n              break;\n\n            case \"networkError\":\n              {\n                status_1 = result.status, message = result.message;\n                statusString = status_1 !== 0 ? \"(\" + status_1 + \") \" : \"\";\n                throw new Error(statusString + \" \" + message);\n              }\n\n            default:\n              return [2\n              /*return*/\n              , assertNever(result)];\n          }\n\n          return [4\n          /*yield*/\n          , delay(retryInterval + (retryJitter * Math.random() | 0))];\n\n        case 3:\n          _b.sent();\n\n          _b.label = 4;\n\n        case 4:\n          i++;\n          return [3\n          /*break*/\n          , 1];\n\n        case 5:\n          throw new Error(\"Rate limited for \" + (maxRetries + 1) + \" consecutive attempts.\");\n      }\n    });\n  });\n}","map":{"version":3,"mappings":"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","names":["assertNever","delay","promisify","ALCHEMY_DISALLOWED_METHODS","makePayloadSender","alchemySend","config","makePayload","currentWriteProvider","getEip1193Provider","writeProvider","sendPayload","payload","disallowedMethod","getDisallowedMethod","sendWithRetries","alchemyError","sendWithProvider","Error","setWriteProvider","provider","undefined","anyProvider","sendMethod","sendAsync","send","bind","method","params","callback","Array","isArray","Promise","all","map","_a","payloads","disallowedRequest","find","p","indexOf","maxRetries","retryInterval","retryJitter","i","result","_b","type","response","status_1","message","statusString","Math","random"],"sourceRoot":"","sources":["../../../src/web3-adapter/sendPayload.ts"],"sourcesContent":["import assertNever from \"assert-never\";\nimport {\n  Eip1193Provider,\n  FullConfig,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  Provider,\n  SingleOrBatchRequest,\n  SingleOrBatchResponse,\n} from \"../types\";\nimport { PayloadFactory } from \"../util/jsonRpc\";\nimport { delay, promisify } from \"../util/promises\";\nimport { AlchemySendFunction } from \"./alchemySend\";\n\nconst ALCHEMY_DISALLOWED_METHODS: string[] = [\n  \"eth_accounts\",\n  \"eth_sendTransaction\",\n  \"eth_sign\",\n  \"eth_signTypedData_v3\",\n  \"eth_signTypedData\",\n  \"personal_sign\",\n];\n\nexport interface PayloadSender {\n  sendPayload: SendPayloadFunction;\n  setWriteProvider(writeProvider: Provider | null | undefined): void;\n}\n\nexport interface SendPayloadFunction {\n  (payload: JsonRpcRequest): Promise<JsonRpcResponse>;\n  (payload: SingleOrBatchRequest): Promise<SingleOrBatchResponse>;\n}\n\nexport function makePayloadSender(\n  alchemySend: AlchemySendFunction,\n  config: FullConfig,\n  makePayload: PayloadFactory,\n): PayloadSender {\n  let currentWriteProvider = getEip1193Provider(\n    config.writeProvider,\n    makePayload,\n  );\n\n  const sendPayload = (\n    payload: SingleOrBatchRequest,\n  ): Promise<SingleOrBatchResponse> => {\n    const disallowedMethod = getDisallowedMethod(payload);\n    if (!disallowedMethod) {\n      try {\n        return sendWithRetries(payload, alchemySend, config);\n      } catch (alchemyError) {\n        // Fallback to write provider, but if both fail throw the error from\n        // Alchemy.\n        if (!currentWriteProvider) {\n          throw alchemyError;\n        }\n        try {\n          return sendWithProvider(currentWriteProvider, payload);\n        } catch {\n          throw alchemyError;\n        }\n      }\n    } else {\n      if (!currentWriteProvider) {\n        throw new Error(\n          `No provider available for method \"${disallowedMethod}\"`,\n        );\n      }\n      return sendWithProvider(currentWriteProvider, payload);\n    }\n  };\n\n  function setWriteProvider(writeProvider: Provider | null | undefined) {\n    currentWriteProvider = getEip1193Provider(writeProvider, makePayload);\n  }\n\n  return { sendPayload: sendPayload as SendPayloadFunction, setWriteProvider };\n}\n\nfunction getEip1193Provider(\n  provider: Provider | null | undefined,\n  makePayload: PayloadFactory,\n): Eip1193Provider | undefined {\n  if (!provider) {\n    return undefined;\n  }\n  const anyProvider: any = provider;\n  const sendMethod = (anyProvider.sendAsync\n    ? anyProvider.sendAsync\n    : anyProvider.send\n  ).bind(anyProvider);\n  return {\n    send: (method, params) =>\n      promisify((callback) =>\n        sendMethod(makePayload(method, params), callback),\n      ),\n  };\n}\n\nfunction sendWithProvider(\n  provider: Eip1193Provider,\n  payload: SingleOrBatchRequest,\n): Promise<SingleOrBatchResponse> {\n  if (!Array.isArray(payload)) {\n    const { method, params } = payload;\n    return provider.send(method, params);\n  } else {\n    // These providers don't support batches, sadly.\n    return Promise.all(\n      payload.map(({ method, params }) => provider.send(method, params)),\n    );\n  }\n}\n\nfunction getDisallowedMethod(\n  payload: SingleOrBatchRequest,\n): string | undefined {\n  const payloads = Array.isArray(payload) ? payload : [payload];\n  const disallowedRequest =\n    payloads.find((p) => ALCHEMY_DISALLOWED_METHODS.indexOf(p.method) >= 0) ||\n    undefined;\n  return disallowedRequest && disallowedRequest.method;\n}\n\nasync function sendWithRetries(\n  payload: SingleOrBatchRequest,\n  alchemySend: AlchemySendFunction,\n  { maxRetries, retryInterval, retryJitter }: FullConfig,\n): Promise<SingleOrBatchResponse> {\n  for (let i = 0; i < maxRetries + 1; i++) {\n    const result = await alchemySend(payload);\n    switch (result.type) {\n      case \"jsonrpc\":\n        return result.response;\n      case \"rateLimit\":\n        break;\n      case \"networkError\": {\n        const { status, message } = result;\n        const statusString = status !== 0 ? `(${status}) ` : \"\";\n        throw new Error(`${statusString} ${message}`);\n      }\n      default:\n        return assertNever(result);\n    }\n    await delay(retryInterval + ((retryJitter * Math.random()) | 0));\n  }\n  throw new Error(`Rate limited for ${maxRetries + 1} consecutive attempts.`);\n}\n"]},"metadata":{},"sourceType":"module"}