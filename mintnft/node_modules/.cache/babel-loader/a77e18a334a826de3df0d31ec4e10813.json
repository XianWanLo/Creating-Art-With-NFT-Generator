{"ast":null,"code":"import { __assign, __awaiter, __generator, __read, __spread } from \"tslib\";\nimport { fromHex, toHex } from \"../util/hex\";\nimport { throwIfCancelled } from \"../util/promises\";\n/**\n * The maximum number of blocks to backfill. If more than this many blocks have\n * been missed, then we'll sadly miss data, but we want to make sure we don't\n * end up requesting thousands of blocks if somebody left their laptop closed\n * for a week.\n */\n\nvar MAX_BACKFILL_BLOCKS = 120;\nexport function makeBackfiller(senders) {\n  return {\n    getNewHeadsBackfill: getNewHeadsBackfill,\n    getLogsBackfill: getLogsBackfill\n  };\n\n  function getNewHeadsBackfill(isCancelled, previousHeads, fromBlockNumber) {\n    return __awaiter(this, void 0, void 0, function () {\n      var toBlockNumber, lastSeenBlockNumber, minBlockNumber, reorgHeads, intermediateHeads;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            throwIfCancelled(isCancelled);\n            return [4\n            /*yield*/\n            , getBlockNumber()];\n\n          case 1:\n            toBlockNumber = _a.sent();\n            throwIfCancelled(isCancelled);\n\n            if (previousHeads.length === 0) {\n              return [2\n              /*return*/\n              , getHeadEventsInRange(Math.max(fromBlockNumber, toBlockNumber - MAX_BACKFILL_BLOCKS) + 1, toBlockNumber + 1)];\n            }\n\n            lastSeenBlockNumber = fromHex(previousHeads[previousHeads.length - 1].number);\n            minBlockNumber = Math.max(0, lastSeenBlockNumber - MAX_BACKFILL_BLOCKS);\n\n            if (lastSeenBlockNumber < minBlockNumber) {\n              return [2\n              /*return*/\n              , getHeadEventsInRange(minBlockNumber, toBlockNumber + 1)];\n            }\n\n            return [4\n            /*yield*/\n            , getReorgHeads(isCancelled, previousHeads)];\n\n          case 2:\n            reorgHeads = _a.sent();\n            throwIfCancelled(isCancelled);\n            return [4\n            /*yield*/\n            , getHeadEventsInRange(lastSeenBlockNumber + 1, toBlockNumber + 1)];\n\n          case 3:\n            intermediateHeads = _a.sent();\n            throwIfCancelled(isCancelled);\n            return [2\n            /*return*/\n            , __spread(reorgHeads, intermediateHeads)];\n        }\n      });\n    });\n  }\n\n  function getReorgHeads(isCancelled, previousHeads) {\n    return __awaiter(this, void 0, void 0, function () {\n      var result, i, oldEvent, blockHead;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            result = [];\n            i = previousHeads.length - 1;\n            _a.label = 1;\n\n          case 1:\n            if (!(i >= 0)) return [3\n            /*break*/\n            , 4];\n            oldEvent = previousHeads[i];\n            return [4\n            /*yield*/\n            , getBlockByNumber(fromHex(oldEvent.number))];\n\n          case 2:\n            blockHead = _a.sent();\n            throwIfCancelled(isCancelled);\n\n            if (oldEvent.hash === blockHead.hash) {\n              return [3\n              /*break*/\n              , 4];\n            }\n\n            result.push(toNewHeadsEvent(blockHead));\n            _a.label = 3;\n\n          case 3:\n            i--;\n            return [3\n            /*break*/\n            , 1];\n\n          case 4:\n            return [2\n            /*return*/\n            , result.reverse()];\n        }\n      });\n    });\n  }\n\n  function getHeadEventsInRange(fromBlockInclusive, toBlockExclusive) {\n    return __awaiter(this, void 0, void 0, function () {\n      var batchParts, i, heads;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            if (fromBlockInclusive >= toBlockExclusive) {\n              return [2\n              /*return*/\n              , []];\n            }\n\n            batchParts = [];\n\n            for (i = fromBlockInclusive; i < toBlockExclusive; i++) {\n              batchParts.push({\n                method: \"eth_getBlockByNumber\",\n                params: [toHex(i), false]\n              });\n            }\n\n            return [4\n            /*yield*/\n            , senders.sendBatch(batchParts)];\n\n          case 1:\n            heads = _a.sent();\n            return [2\n            /*return*/\n            , heads.map(toNewHeadsEvent)];\n        }\n      });\n    });\n  }\n\n  function getBlockByNumber(blockNumber) {\n    return __awaiter(this, void 0, void 0, function () {\n      return __generator(this, function (_a) {\n        return [2\n        /*return*/\n        , senders.send(\"eth_getBlockByNumber\", [toHex(blockNumber), false])];\n      });\n    });\n  }\n\n  function getLogsBackfill(isCancelled, filter, previousLogs, fromBlockNumber) {\n    return __awaiter(this, void 0, void 0, function () {\n      var toBlockNumber, lastSeenBlockNumber, minBlockNumber, commonAncestorNumber, removedLogs, addedLogs;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            throwIfCancelled(isCancelled);\n            return [4\n            /*yield*/\n            , getBlockNumber()];\n\n          case 1:\n            toBlockNumber = _a.sent();\n            throwIfCancelled(isCancelled);\n\n            if (previousLogs.length === 0) {\n              return [2\n              /*return*/\n              , getLogsInRange(filter, Math.max(fromBlockNumber, toBlockNumber - MAX_BACKFILL_BLOCKS) + 1, toBlockNumber + 1)];\n            }\n\n            lastSeenBlockNumber = fromHex(previousLogs[previousLogs.length - 1].blockNumber);\n            minBlockNumber = Math.max(0, lastSeenBlockNumber - MAX_BACKFILL_BLOCKS);\n\n            if (lastSeenBlockNumber < minBlockNumber) {\n              return [2\n              /*return*/\n              , getLogsInRange(filter, minBlockNumber, toBlockNumber + 1)];\n            }\n\n            return [4\n            /*yield*/\n            , getCommonAncestorNumber(isCancelled, previousLogs)];\n\n          case 2:\n            commonAncestorNumber = _a.sent();\n            throwIfCancelled(isCancelled);\n            removedLogs = previousLogs.filter(function (log) {\n              return fromHex(log.blockNumber) > commonAncestorNumber;\n            }).map(function (log) {\n              return __assign(__assign({}, log), {\n                removed: true\n              });\n            });\n            return [4\n            /*yield*/\n            , getLogsInRange(filter, commonAncestorNumber + 1, toBlockNumber + 1)];\n\n          case 3:\n            addedLogs = _a.sent();\n            throwIfCancelled(isCancelled);\n            return [2\n            /*return*/\n            , __spread(removedLogs, addedLogs)];\n        }\n      });\n    });\n  }\n\n  function getCommonAncestorNumber(isCancelled, previousLogs) {\n    return __awaiter(this, void 0, void 0, function () {\n      var i, _a, blockHash, blockNumber, hash;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            i = previousLogs.length - 1;\n            _b.label = 1;\n\n          case 1:\n            if (!(i >= 0)) return [3\n            /*break*/\n            , 4];\n            _a = previousLogs[i], blockHash = _a.blockHash, blockNumber = _a.blockNumber;\n            return [4\n            /*yield*/\n            , getBlockByNumber(fromHex(blockNumber))];\n\n          case 2:\n            hash = _b.sent().hash;\n            throwIfCancelled(isCancelled);\n\n            if (blockHash === hash) {\n              return [2\n              /*return*/\n              , fromHex(blockNumber)];\n            }\n\n            _b.label = 3;\n\n          case 3:\n            i--;\n            return [3\n            /*break*/\n            , 1];\n\n          case 4:\n            return [2\n            /*return*/\n            , Number.NEGATIVE_INFINITY];\n        }\n      });\n    });\n  }\n\n  function getLogsInRange(filter, fromBlockInclusive, toBlockExclusive) {\n    return __awaiter(this, void 0, void 0, function () {\n      var rangeFilter;\n      return __generator(this, function (_a) {\n        if (fromBlockInclusive >= toBlockExclusive) {\n          return [2\n          /*return*/\n          , []];\n        }\n\n        rangeFilter = __assign(__assign({}, filter), {\n          fromBlock: toHex(fromBlockInclusive),\n          toBlock: toHex(toBlockExclusive - 1)\n        });\n        return [2\n        /*return*/\n        , senders.send(\"eth_getLogs\", [rangeFilter])];\n      });\n    });\n  }\n\n  function getBlockNumber() {\n    return __awaiter(this, void 0, void 0, function () {\n      var blockNumberHex;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , senders.send(\"eth_blockNumber\")];\n\n          case 1:\n            blockNumberHex = _a.sent();\n            return [2\n            /*return*/\n            , fromHex(blockNumberHex)];\n        }\n      });\n    });\n  }\n}\n\nfunction toNewHeadsEvent(head) {\n  var result = __assign({}, head);\n\n  delete result.totalDifficulty;\n  delete result.transactions;\n  delete result.uncles;\n  return result;\n}\n\nexport function dedupeNewHeads(events) {\n  return dedupe(events, function (event) {\n    return event.hash;\n  });\n}\nexport function dedupeLogs(events) {\n  return dedupe(events, function (event) {\n    return event.blockHash + \"/\" + event.logIndex;\n  });\n}\n\nfunction dedupe(items, getKey) {\n  var keysSeen = new Set();\n  var result = [];\n  items.forEach(function (item) {\n    var key = getKey(item);\n\n    if (!keysSeen.has(key)) {\n      keysSeen.add(key);\n      result.push(item);\n    }\n  });\n  return result;\n}","map":{"version":3,"sources":["../../../src/subscriptions/subscriptionBackfill.ts"],"names":[],"mappings":"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","sourcesContent":["import { fromHex, toHex } from \"../util/hex\";\nimport { BatchPart, JsonRpcSenders } from \"../util/jsonRpc\";\nimport { throwIfCancelled } from \"../util/promises\";\n\nexport interface NewHeadsEvent {\n  author: string;\n  difficulty: string;\n  extraData: string;\n  gasLimit: string;\n  gasUsed: string;\n  hash: string;\n  logsBloom: string;\n  miner: string;\n  mixHash: string;\n  nonce: string;\n  number: string;\n  parentHash: string;\n  receiptsRoot: string;\n  sealFields: string[];\n  sha3Uncles: string;\n  size: string;\n  stateRoot: string;\n  timestamp: string;\n  transactionsRoot: string;\n}\n\n/**\n * The return type of eth_getBlocksByHash.\n */\nexport interface BlockHead extends NewHeadsEvent {\n  totalDifficulty: string;\n  transactions: any[];\n  uncles: string[];\n}\n\nexport interface LogsEvent {\n  address: string;\n  blockHash: string;\n  blockNumber: string;\n  data: string;\n  logIndex: string;\n  topics: string[];\n  transactionHash: string;\n  transactionIndex: string;\n  removed?: boolean;\n}\n\nexport interface LogsSubscriptionFilter {\n  address?: string | string[];\n  topics?: Array<string | string[] | null>;\n}\n\ninterface GetLogsOptions extends LogsSubscriptionFilter {\n  fromBlock?: string;\n  toBlock?: string;\n}\n\nexport type Backfiller = ReturnType<typeof makeBackfiller>;\n\n/**\n * The maximum number of blocks to backfill. If more than this many blocks have\n * been missed, then we'll sadly miss data, but we want to make sure we don't\n * end up requesting thousands of blocks if somebody left their laptop closed\n * for a week.\n */\nconst MAX_BACKFILL_BLOCKS = 120;\n\nexport function makeBackfiller(senders: JsonRpcSenders) {\n  return { getNewHeadsBackfill, getLogsBackfill };\n\n  async function getNewHeadsBackfill(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[],\n    fromBlockNumber: number,\n  ): Promise<NewHeadsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await getBlockNumber();\n    throwIfCancelled(isCancelled);\n    if (previousHeads.length === 0) {\n      return getHeadEventsInRange(\n        Math.max(fromBlockNumber, toBlockNumber - MAX_BACKFILL_BLOCKS) + 1,\n        toBlockNumber + 1,\n      );\n    }\n    const lastSeenBlockNumber = fromHex(\n      previousHeads[previousHeads.length - 1].number,\n    );\n    const minBlockNumber = Math.max(\n      0,\n      lastSeenBlockNumber - MAX_BACKFILL_BLOCKS,\n    );\n    if (lastSeenBlockNumber < minBlockNumber) {\n      return getHeadEventsInRange(minBlockNumber, toBlockNumber + 1);\n    }\n    const reorgHeads: NewHeadsEvent[] = await getReorgHeads(\n      isCancelled,\n      previousHeads,\n    );\n    throwIfCancelled(isCancelled);\n    const intermediateHeads: NewHeadsEvent[] = await getHeadEventsInRange(\n      lastSeenBlockNumber + 1,\n      toBlockNumber + 1,\n    );\n    throwIfCancelled(isCancelled);\n    return [...reorgHeads, ...intermediateHeads];\n  }\n\n  async function getReorgHeads(\n    isCancelled: () => boolean,\n    previousHeads: NewHeadsEvent[],\n  ): Promise<NewHeadsEvent[]> {\n    const result: NewHeadsEvent[] = [];\n    for (let i = previousHeads.length - 1; i >= 0; i--) {\n      const oldEvent = previousHeads[i];\n      const blockHead = await getBlockByNumber(fromHex(oldEvent.number));\n      throwIfCancelled(isCancelled);\n      if (oldEvent.hash === blockHead.hash) {\n        break;\n      }\n      result.push(toNewHeadsEvent(blockHead));\n    }\n    return result.reverse();\n  }\n\n  async function getHeadEventsInRange(\n    fromBlockInclusive: number,\n    toBlockExclusive: number,\n  ): Promise<NewHeadsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const batchParts: BatchPart[] = [];\n    for (let i = fromBlockInclusive; i < toBlockExclusive; i++) {\n      batchParts.push({\n        method: \"eth_getBlockByNumber\",\n        params: [toHex(i), false],\n      });\n    }\n    const heads = await senders.sendBatch(batchParts);\n    return heads.map(toNewHeadsEvent);\n  }\n\n  async function getBlockByNumber(blockNumber: number): Promise<BlockHead> {\n    return senders.send(\"eth_getBlockByNumber\", [toHex(blockNumber), false]);\n  }\n\n  async function getLogsBackfill(\n    isCancelled: () => boolean,\n    filter: LogsSubscriptionFilter,\n    previousLogs: LogsEvent[],\n    fromBlockNumber: number,\n  ): Promise<LogsEvent[]> {\n    throwIfCancelled(isCancelled);\n    const toBlockNumber = await getBlockNumber();\n    throwIfCancelled(isCancelled);\n    if (previousLogs.length === 0) {\n      return getLogsInRange(\n        filter,\n        Math.max(fromBlockNumber, toBlockNumber - MAX_BACKFILL_BLOCKS) + 1,\n        toBlockNumber + 1,\n      );\n    }\n    const lastSeenBlockNumber = fromHex(\n      previousLogs[previousLogs.length - 1].blockNumber,\n    );\n    const minBlockNumber = Math.max(\n      0,\n      lastSeenBlockNumber - MAX_BACKFILL_BLOCKS,\n    );\n    if (lastSeenBlockNumber < minBlockNumber) {\n      return getLogsInRange(filter, minBlockNumber, toBlockNumber + 1);\n    }\n    const commonAncestorNumber = await getCommonAncestorNumber(\n      isCancelled,\n      previousLogs,\n    );\n    throwIfCancelled(isCancelled);\n    const removedLogs = previousLogs\n      .filter((log) => fromHex(log.blockNumber) > commonAncestorNumber)\n      .map((log) => ({ ...log, removed: true }));\n    const addedLogs = await getLogsInRange(\n      filter,\n      commonAncestorNumber + 1,\n      toBlockNumber + 1,\n    );\n    throwIfCancelled(isCancelled);\n    return [...removedLogs, ...addedLogs];\n  }\n\n  async function getCommonAncestorNumber(\n    isCancelled: () => boolean,\n    previousLogs: LogsEvent[],\n  ): Promise<number> {\n    for (let i = previousLogs.length - 1; i >= 0; i--) {\n      const { blockHash, blockNumber } = previousLogs[i];\n      const { hash } = await getBlockByNumber(fromHex(blockNumber));\n      throwIfCancelled(isCancelled);\n      if (blockHash === hash) {\n        return fromHex(blockNumber);\n      }\n    }\n    return Number.NEGATIVE_INFINITY;\n  }\n\n  async function getLogsInRange(\n    filter: LogsSubscriptionFilter,\n    fromBlockInclusive: number,\n    toBlockExclusive: number,\n  ): Promise<LogsEvent[]> {\n    if (fromBlockInclusive >= toBlockExclusive) {\n      return [];\n    }\n    const rangeFilter: GetLogsOptions = {\n      ...filter,\n      fromBlock: toHex(fromBlockInclusive),\n      toBlock: toHex(toBlockExclusive - 1),\n    };\n    return senders.send(\"eth_getLogs\", [rangeFilter]);\n  }\n\n  async function getBlockNumber(): Promise<number> {\n    const blockNumberHex: string = await senders.send(\"eth_blockNumber\");\n    return fromHex(blockNumberHex);\n  }\n}\n\nfunction toNewHeadsEvent(head: BlockHead): NewHeadsEvent {\n  const result: NewHeadsEvent & Partial<BlockHead> = { ...head };\n  delete result.totalDifficulty;\n  delete result.transactions;\n  delete result.uncles;\n  return result;\n}\n\nexport function dedupeNewHeads(events: NewHeadsEvent[]): NewHeadsEvent[] {\n  return dedupe(events, (event) => event.hash);\n}\n\nexport function dedupeLogs(events: LogsEvent[]): LogsEvent[] {\n  return dedupe(events, (event) => `${event.blockHash}/${event.logIndex}`);\n}\n\nfunction dedupe<T>(items: T[], getKey: (item: T) => any): T[] {\n  const keysSeen: Set<any> = new Set();\n  const result: T[] = [];\n  items.forEach((item) => {\n    const key = getKey(item);\n    if (!keysSeen.has(key)) {\n      keysSeen.add(key);\n      result.push(item);\n    }\n  });\n  return result;\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}