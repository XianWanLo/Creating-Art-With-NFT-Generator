{"ast":null,"code":"import { __assign, __awaiter, __extends, __generator, __read, __spread, __values } from \"tslib\";\nimport EventEmitter from \"eventemitter3\";\nimport { dedupeLogs, dedupeNewHeads, makeBackfiller } from \"../subscriptions/subscriptionBackfill\";\nimport { isSubscriptionEvent } from \"../types\";\nimport { fromHex } from \"../util/hex\";\nimport { makeResponse } from \"../util/jsonRpc\";\nimport { callWhenDone, makeCancelToken, throwIfCancelled, withBackoffRetries, withTimeout } from \"../util/promises\";\nvar HEARTBEAT_INTERVAL = 30000;\nvar HEARTBEAT_WAIT_TIME = 10000;\nvar BACKFILL_TIMEOUT = 60000;\nvar BACKFILL_RETRIES = 5;\n/**\n * Subscriptions have a memory of recent events they have sent so that in the\n * event that they disconnect and need to backfill, they can detect re-orgs.\n * Keep a buffer that goes back at least these many blocks, the maximum amount\n * at which we might conceivably see a re-org.\n *\n * Note that while our buffer goes back this many blocks, it may contain more\n * than this many elements, since in the case of logs subscriptions more than\n * one event may be emitted for a block.\n */\n\nvar RETAINED_EVENT_BLOCK_COUNT = 10;\n\nvar AlchemyWebSocketProvider =\n/** @class */\nfunction (_super) {\n  __extends(AlchemyWebSocketProvider, _super);\n\n  function AlchemyWebSocketProvider(ws, sendPayload, senders) {\n    var _this = _super.call(this) || this;\n\n    _this.ws = ws;\n    _this.sendPayload = sendPayload;\n    _this.senders = senders; // In the case of a WebSocket reconnection, all subscriptions are lost and we\n    // create new ones to replace them, but we want to create the illusion that\n    // the original subscriptions persist. Thus, maintain a mapping from the\n    // \"virtual\" subscription ids which are visible to the consumer to the\n    // \"physical\" subscription ids of the actual connections. This terminology is\n    // borrowed from virtual and physical memory, which has a similar mapping.\n\n    _this.virtualSubscriptionsById = new Map();\n    _this.virtualIdsByPhysicalId = new Map();\n    _this.cancelBackfill = noop;\n\n    _this.startHeartbeat = function () {\n      if (_this.heartbeatIntervalId != null) {\n        return;\n      }\n\n      _this.heartbeatIntervalId = setInterval(function () {\n        return __awaiter(_this, void 0, void 0, function () {\n          var _a;\n\n          return __generator(this, function (_b) {\n            switch (_b.label) {\n              case 0:\n                _b.trys.push([0, 2,, 3]);\n\n                return [4\n                /*yield*/\n                , withTimeout(this.senders.send(\"net_version\"), HEARTBEAT_WAIT_TIME)];\n\n              case 1:\n                _b.sent();\n\n                return [3\n                /*break*/\n                , 3];\n\n              case 2:\n                _a = _b.sent();\n                this.ws.reconnect();\n                return [3\n                /*break*/\n                , 3];\n\n              case 3:\n                return [2\n                /*return*/\n                ];\n            }\n          });\n        });\n      }, HEARTBEAT_INTERVAL);\n    };\n\n    _this.stopHeartbeatAndBackfill = function () {\n      if (_this.heartbeatIntervalId != null) {\n        clearInterval(_this.heartbeatIntervalId);\n        _this.heartbeatIntervalId = undefined;\n      }\n\n      _this.cancelBackfill();\n    };\n\n    _this.handleMessage = function (event) {\n      var message = JSON.parse(event.data);\n\n      if (!isSubscriptionEvent(message)) {\n        return;\n      }\n\n      var physicalId = message.params.subscription;\n\n      var virtualId = _this.virtualIdsByPhysicalId.get(physicalId);\n\n      if (!virtualId) {\n        return;\n      }\n\n      var subscription = _this.virtualSubscriptionsById.get(virtualId);\n\n      if (subscription.method !== \"eth_subscribe\") {\n        _this.emitGenericEvent(virtualId, message.params.result);\n\n        return;\n      }\n\n      switch (subscription.params[0]) {\n        case \"newHeads\":\n          {\n            var newHeadsSubscription = subscription;\n            var newHeadsMessage = message;\n            var isBackfilling = newHeadsSubscription.isBackfilling,\n                backfillBuffer = newHeadsSubscription.backfillBuffer;\n            var result = newHeadsMessage.params.result;\n\n            if (isBackfilling) {\n              addToNewHeadsEventsBuffer(backfillBuffer, result);\n            } else {\n              _this.emitNewHeadsEvent(virtualId, result);\n            }\n\n            break;\n          }\n\n        case \"logs\":\n          {\n            var logsSubscription = subscription;\n            var logsMessage = message;\n            var isBackfilling = logsSubscription.isBackfilling,\n                backfillBuffer = logsSubscription.backfillBuffer;\n            var result = logsMessage.params.result;\n\n            if (isBackfilling) {\n              addToLogsEventsBuffer(backfillBuffer, result);\n            } else {\n              _this.emitLogsEvent(virtualId, result);\n            }\n\n            break;\n          }\n\n        default:\n          _this.emitGenericEvent(virtualId, message.params.result);\n\n      }\n    };\n\n    _this.handleReopen = function () {\n      var e_1, _a;\n\n      _this.virtualIdsByPhysicalId.clear();\n\n      var _b = makeCancelToken(),\n          cancel = _b.cancel,\n          isCancelled = _b.isCancelled;\n\n      _this.cancelBackfill = cancel;\n\n      var _loop_1 = function _loop_1(subscription) {\n        (function () {\n          return __awaiter(_this, void 0, void 0, function () {\n            var error_1;\n            return __generator(this, function (_a) {\n              switch (_a.label) {\n                case 0:\n                  _a.trys.push([0, 2,, 3]);\n\n                  return [4\n                  /*yield*/\n                  , this.resubscribeAndBackfill(isCancelled, subscription)];\n\n                case 1:\n                  _a.sent();\n\n                  return [3\n                  /*break*/\n                  , 3];\n\n                case 2:\n                  error_1 = _a.sent();\n\n                  if (!isCancelled()) {\n                    console.error(\"Error while backfilling \\\"\" + subscription.params[0] + \"\\\" subscription. Some events may be missing.\", error_1);\n                  }\n\n                  return [3\n                  /*break*/\n                  , 3];\n\n                case 3:\n                  return [2\n                  /*return*/\n                  ];\n              }\n            });\n          });\n        })();\n      };\n\n      try {\n        for (var _c = __values(_this.virtualSubscriptionsById.values()), _d = _c.next(); !_d.done; _d = _c.next()) {\n          var subscription = _d.value;\n\n          _loop_1(subscription);\n        }\n      } catch (e_1_1) {\n        e_1 = {\n          error: e_1_1\n        };\n      } finally {\n        try {\n          if (_d && !_d.done && (_a = _c.return)) _a.call(_c);\n        } finally {\n          if (e_1) throw e_1.error;\n        }\n      }\n\n      _this.startHeartbeat();\n    };\n\n    _this.backfiller = makeBackfiller(senders);\n\n    _this.addSocketListeners();\n\n    _this.startHeartbeat();\n\n    return _this;\n  }\n\n  AlchemyWebSocketProvider.prototype.send = function (request, callback) {\n    if (isSubscribeRequest(request)) {\n      var id = request.id;\n\n      if (id === undefined) {\n        // The JSON-RPC spec says to return nothing if there is no request id.\n        return;\n      }\n\n      callWhenDone(this.subscribe(request), callback);\n      return;\n    }\n\n    if (isUnsubscribeRequest(request)) {\n      callWhenDone(this.unsubscribe(request), callback);\n      return;\n    }\n\n    callWhenDone(this.sendPayload(request), callback);\n  };\n\n  AlchemyWebSocketProvider.prototype.supportsSubscriptions = function () {\n    return true;\n  };\n\n  AlchemyWebSocketProvider.prototype.disconnect = function (code, reason) {\n    this.removeSocketListeners();\n    this.removeAllListeners();\n    this.stopHeartbeatAndBackfill();\n    this.ws.close(code, reason);\n  };\n\n  AlchemyWebSocketProvider.prototype.connect = function () {// No-op. We're already connected when passed a websocket in the\n    // constructor.\n  };\n\n  AlchemyWebSocketProvider.prototype.reset = function () {// No-op.\n  };\n\n  AlchemyWebSocketProvider.prototype.reconnect = function () {// No-op. This isn't called anywhere.\n  };\n\n  AlchemyWebSocketProvider.prototype.subscribe = function (request) {\n    return __awaiter(this, void 0, void 0, function () {\n      var method, _a, params, startingBlockNumber, response, id;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            method = request.method, _a = request.params, params = _a === void 0 ? [] : _a;\n            return [4\n            /*yield*/\n            , this.getBlockNumber()];\n\n          case 1:\n            startingBlockNumber = _b.sent();\n            return [4\n            /*yield*/\n            , this.sendPayload(request)];\n\n          case 2:\n            response = _b.sent();\n            id = response.result;\n            this.virtualSubscriptionsById.set(id, {\n              method: method,\n              params: params,\n              startingBlockNumber: startingBlockNumber,\n              virtualId: id,\n              physicalId: id,\n              sentEvents: [],\n              isBackfilling: false,\n              backfillBuffer: []\n            });\n            this.virtualIdsByPhysicalId.set(id, id);\n            return [2\n            /*return*/\n            , makeResponse(request.id, id)];\n        }\n      });\n    });\n  };\n\n  AlchemyWebSocketProvider.prototype.unsubscribe = function (request) {\n    var _a;\n\n    return __awaiter(this, void 0, void 0, function () {\n      var subscriptionId, virtualSubscription, physicalId, physicalRequest;\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            subscriptionId = (_a = request.params) === null || _a === void 0 ? void 0 : _a[0];\n            virtualSubscription = this.virtualSubscriptionsById.get(subscriptionId);\n\n            if (!virtualSubscription) {\n              return [2\n              /*return*/\n              , makeResponse(request.id, false)];\n            }\n\n            physicalId = virtualSubscription.physicalId;\n            physicalRequest = __assign(__assign({}, request), {\n              params: [physicalId]\n            });\n            return [4\n            /*yield*/\n            , this.sendPayload(physicalRequest)];\n\n          case 1:\n            _b.sent();\n\n            this.virtualSubscriptionsById.delete(subscriptionId);\n            this.virtualIdsByPhysicalId.delete(physicalId);\n            return [2\n            /*return*/\n            , makeResponse(request.id, true)];\n        }\n      });\n    });\n  };\n\n  AlchemyWebSocketProvider.prototype.addSocketListeners = function () {\n    this.ws.addEventListener(\"message\", this.handleMessage);\n    this.ws.addEventListener(\"reopen\", this.handleReopen);\n    this.ws.addEventListener(\"down\", this.stopHeartbeatAndBackfill);\n  };\n\n  AlchemyWebSocketProvider.prototype.removeSocketListeners = function () {\n    this.ws.removeEventListener(\"message\", this.handleMessage);\n    this.ws.removeEventListener(\"reopen\", this.handleReopen);\n    this.ws.removeEventListener(\"down\", this.stopHeartbeatAndBackfill);\n  };\n\n  AlchemyWebSocketProvider.prototype.resubscribeAndBackfill = function (isCancelled, subscription) {\n    return __awaiter(this, void 0, void 0, function () {\n      var virtualId, method, params, sentEvents, backfillBuffer, startingBlockNumber, physicalId, _a, backfillEvents, events, filter_1, backfillEvents, events;\n\n      var _this = this;\n\n      return __generator(this, function (_b) {\n        switch (_b.label) {\n          case 0:\n            virtualId = subscription.virtualId, method = subscription.method, params = subscription.params, sentEvents = subscription.sentEvents, backfillBuffer = subscription.backfillBuffer, startingBlockNumber = subscription.startingBlockNumber;\n            subscription.isBackfilling = true;\n            backfillBuffer.length = 0;\n            _b.label = 1;\n\n          case 1:\n            _b.trys.push([1,, 9, 10]);\n\n            return [4\n            /*yield*/\n            , this.senders.send(method, params)];\n\n          case 2:\n            physicalId = _b.sent();\n            throwIfCancelled(isCancelled);\n            subscription.physicalId = physicalId;\n            this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n            _a = params[0];\n\n            switch (_a) {\n              case \"newHeads\":\n                return [3\n                /*break*/\n                , 3];\n\n              case \"logs\":\n                return [3\n                /*break*/\n                , 5];\n            }\n\n            return [3\n            /*break*/\n            , 7];\n\n          case 3:\n            return [4\n            /*yield*/\n            , withBackoffRetries(function () {\n              return withTimeout(_this.backfiller.getNewHeadsBackfill(isCancelled, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT);\n            }, BACKFILL_RETRIES, function () {\n              return !isCancelled();\n            })];\n\n          case 4:\n            backfillEvents = _b.sent();\n            throwIfCancelled(isCancelled);\n            events = dedupeNewHeads(__spread(backfillEvents, backfillBuffer));\n            events.forEach(function (event) {\n              return _this.emitNewHeadsEvent(virtualId, event);\n            });\n            return [3\n            /*break*/\n            , 8];\n\n          case 5:\n            filter_1 = params[1] || {};\n            return [4\n            /*yield*/\n            , withBackoffRetries(function () {\n              return withTimeout(_this.backfiller.getLogsBackfill(isCancelled, filter_1, sentEvents, startingBlockNumber), BACKFILL_TIMEOUT);\n            }, BACKFILL_RETRIES, function () {\n              return !isCancelled();\n            })];\n\n          case 6:\n            backfillEvents = _b.sent();\n            throwIfCancelled(isCancelled);\n            events = dedupeLogs(__spread(backfillEvents, backfillBuffer));\n            events.forEach(function (event) {\n              return _this.emitLogsEvent(virtualId, event);\n            });\n            return [3\n            /*break*/\n            , 8];\n\n          case 7:\n            return [3\n            /*break*/\n            , 8];\n\n          case 8:\n            return [3\n            /*break*/\n            , 10];\n\n          case 9:\n            subscription.isBackfilling = false;\n            backfillBuffer.length = 0;\n            return [7\n            /*endfinally*/\n            ];\n\n          case 10:\n            return [2\n            /*return*/\n            ];\n        }\n      });\n    });\n  };\n\n  AlchemyWebSocketProvider.prototype.getBlockNumber = function () {\n    return __awaiter(this, void 0, void 0, function () {\n      var blockNumberHex;\n      return __generator(this, function (_a) {\n        switch (_a.label) {\n          case 0:\n            return [4\n            /*yield*/\n            , this.senders.send(\"eth_blockNumber\")];\n\n          case 1:\n            blockNumberHex = _a.sent();\n            return [2\n            /*return*/\n            , fromHex(blockNumberHex)];\n        }\n      });\n    });\n  };\n\n  AlchemyWebSocketProvider.prototype.emitNewHeadsEvent = function (virtualId, result) {\n    this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n  };\n\n  AlchemyWebSocketProvider.prototype.emitLogsEvent = function (virtualId, result) {\n    this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n  };\n  /**\n   * Emits an event to consumers, but also remembers it in its subscriptions's\n   * `sentEvents` buffer so that we can detect re-orgs if the connection drops\n   * and needs to be reconnected.\n   */\n\n\n  AlchemyWebSocketProvider.prototype.emitAndRememberEvent = function (virtualId, result, getBlockNumber) {\n    var subscription = this.virtualSubscriptionsById.get(virtualId);\n\n    if (!subscription) {\n      return;\n    } // Web3 modifies these event objects once we pass them on (changing hex\n    // numbers to numbers). We want the original event, so make a defensive\n    // copy.\n\n\n    addToPastEventsBuffer(subscription.sentEvents, __assign({}, result), getBlockNumber);\n    this.emitGenericEvent(virtualId, result);\n  };\n\n  AlchemyWebSocketProvider.prototype.emitGenericEvent = function (virtualId, result) {\n    var event = {\n      jsonrpc: \"2.0\",\n      method: \"eth_subscription\",\n      params: {\n        subscription: virtualId,\n        result: result\n      }\n    };\n    this.emit(\"data\", event);\n  };\n\n  return AlchemyWebSocketProvider;\n}(EventEmitter);\n\nexport { AlchemyWebSocketProvider };\n\nfunction addToNewHeadsEventsBuffer(pastEvents, event) {\n  addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\n\nfunction addToLogsEventsBuffer(pastEvents, event) {\n  addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n/**\n * Adds a new event to an array of events, evicting any events which\n * are so old that they will no longer feasibly be part of a reorg.\n */\n\n\nfunction addToPastEventsBuffer(pastEvents, event, getBlockNumber) {\n  var currentBlockNumber = getBlockNumber(event); // Find first index of an event recent enough to retain, then drop everything\n  // at a lower index.\n\n  var firstGoodIndex = pastEvents.findIndex(function (e) {\n    return getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT;\n  });\n\n  if (firstGoodIndex === -1) {\n    pastEvents.length = 0;\n  } else {\n    pastEvents.splice(0, firstGoodIndex);\n  }\n\n  pastEvents.push(event);\n}\n\nfunction isSubscribeRequest(request) {\n  return !Array.isArray(request) && request.method === \"eth_subscribe\";\n}\n\nfunction isUnsubscribeRequest(request) {\n  return !Array.isArray(request) && request.method === \"eth_unsubscribe\";\n}\n\nfunction getNewHeadsBlockNumber(event) {\n  return fromHex(event.number);\n}\n\nfunction getLogsBlockNumber(event) {\n  return fromHex(event.blockNumber);\n}\n\nfunction noop() {// Nothing.\n}","map":{"version":3,"sources":["../../../src/web3-adapter/webSocketProvider.ts"],"names":[],"mappings":";AAAA,OAAO,YAAP,MAAyB,eAAzB;AAEA,SAEE,UAFF,EAGE,cAHF,EAME,cANF,QAQO,uCARP;AASA,SACE,mBADF,QAQO,UARP;AASA,SAAS,OAAT,QAAwB,aAAxB;AACA,SAAyB,YAAzB,QAA6C,iBAA7C;AACA,SACE,YADF,EAEE,eAFF,EAGE,gBAHF,EAIE,kBAJF,EAKE,WALF,QAMO,kBANP;AASA,IAAM,kBAAkB,GAAG,KAA3B;AACA,IAAM,mBAAmB,GAAG,KAA5B;AACA,IAAM,gBAAgB,GAAG,KAAzB;AACA,IAAM,gBAAgB,GAAG,CAAzB;AACA;;;;;;;;;AASG;;AACH,IAAM,0BAA0B,GAAG,EAAnC;;AAgDA,IAAA,wBAAA;AAAA;AAAA,UAAA,MAAA,EAAA;AACU,EAAA,SAAA,CAAA,wBAAA,EAAA,MAAA,CAAA;;AAiBR,WAAA,wBAAA,CACmB,EADnB,EAEmB,WAFnB,EAGmB,OAHnB,EAG0C;AAH1C,QAAA,KAAA,GAKE,MAAA,CAAA,IAAA,CAAA,IAAA,KAAO,IALT;;AACmB,IAAA,KAAA,CAAA,EAAA,GAAA,EAAA;AACA,IAAA,KAAA,CAAA,WAAA,GAAA,WAAA;AACA,IAAA,KAAA,CAAA,OAAA,GAAA,OAAA,CAAuB,CAlB1C;AACA;AACA;AACA;AACA;AACA;;AACiB,IAAA,KAAA,CAAA,wBAAA,GAGb,IAAI,GAAJ,EAHa;AAIA,IAAA,KAAA,CAAA,sBAAA,GAA8C,IAAI,GAAJ,EAA9C;AAGT,IAAA,KAAA,CAAA,cAAA,GAAiB,IAAjB;;AAwGA,IAAA,KAAA,CAAA,cAAA,GAAiB,YAAA;AACvB,UAAI,KAAI,CAAC,mBAAL,IAA4B,IAAhC,EAAsC;AACpC;AACD;;AACD,MAAA,KAAI,CAAC,mBAAL,GAA2B,WAAW,CAAC,YAAA;AAAA,eAAA,SAAA,CAAA,KAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,YAAA;;;;;;;;AAEnC,uBAAA,CAAA;AAAA;AAAA,kBAAM,WAAW,CACf,KAAK,OAAL,CAAa,IAAb,CAAkB,aAAlB,CADe,EAEf,mBAFe,CAAjB,CAAA;;;AAAA,gBAAA,EAAA,CAAA,IAAA;;;;;;;;AAKA,qBAAK,EAAL,CAAQ,SAAR;;;;;;;;;;;SAPmC,CAAA;AAStC,OATqC,EASnC,kBATmC,CAAtC;AAUD,KAdO;;AAgBA,IAAA,KAAA,CAAA,wBAAA,GAA2B,YAAA;AACjC,UAAI,KAAI,CAAC,mBAAL,IAA4B,IAAhC,EAAsC;AACpC,QAAA,aAAa,CAAC,KAAI,CAAC,mBAAN,CAAb;AACA,QAAA,KAAI,CAAC,mBAAL,GAA2B,SAA3B;AACD;;AACD,MAAA,KAAI,CAAC,cAAL;AACD,KANO;;AAQA,IAAA,KAAA,CAAA,aAAA,GAAgB,UAAC,KAAD,EAAoB;AAC1C,UAAM,OAAO,GAAqB,IAAI,CAAC,KAAL,CAAW,KAAK,CAAC,IAAjB,CAAlC;;AACA,UAAI,CAAC,mBAAmB,CAAC,OAAD,CAAxB,EAAmC;AACjC;AACD;;AACD,UAAM,UAAU,GAAG,OAAO,CAAC,MAAR,CAAe,YAAlC;;AACA,UAAM,SAAS,GAAG,KAAI,CAAC,sBAAL,CAA4B,GAA5B,CAAgC,UAAhC,CAAlB;;AACA,UAAI,CAAC,SAAL,EAAgB;AACd;AACD;;AACD,UAAM,YAAY,GAAG,KAAI,CAAC,wBAAL,CAA8B,GAA9B,CAAkC,SAAlC,CAArB;;AACA,UAAI,YAAY,CAAC,MAAb,KAAwB,eAA5B,EAA6C;AAC3C,QAAA,KAAI,CAAC,gBAAL,CAAsB,SAAtB,EAAiC,OAAO,CAAC,MAAR,CAAe,MAAhD;;AACA;AACD;;AACD,cAAQ,YAAY,CAAC,MAAb,CAAoB,CAApB,CAAR;AACE,aAAK,UAAL;AAAiB;AACf,gBAAM,oBAAoB,GAAG,YAA7B;AACA,gBAAM,eAAe,GAAG,OAAxB;AACQ,gBAAA,aAAa,GAAqB,oBAAoB,CAAzC,aAAb;AAAA,gBAAe,cAAc,GAAK,oBAAoB,CAAzB,cAA7B;AACA,gBAAA,MAAM,GAAK,eAAe,CAAC,MAAhB,CAAL,MAAN;;AACR,gBAAI,aAAJ,EAAmB;AACjB,cAAA,yBAAyB,CAAC,cAAD,EAAiB,MAAjB,CAAzB;AACD,aAFD,MAEO;AACL,cAAA,KAAI,CAAC,iBAAL,CAAuB,SAAvB,EAAkC,MAAlC;AACD;;AACD;AACD;;AACD,aAAK,MAAL;AAAa;AACX,gBAAM,gBAAgB,GAAG,YAAzB;AACA,gBAAM,WAAW,GAAG,OAApB;AACQ,gBAAA,aAAa,GAAqB,gBAAgB,CAArC,aAAb;AAAA,gBAAe,cAAc,GAAK,gBAAgB,CAArB,cAA7B;AACA,gBAAA,MAAM,GAAK,WAAW,CAAC,MAAZ,CAAL,MAAN;;AACR,gBAAI,aAAJ,EAAmB;AACjB,cAAA,qBAAqB,CAAC,cAAD,EAAiB,MAAjB,CAArB;AACD,aAFD,MAEO;AACL,cAAA,KAAI,CAAC,aAAL,CAAmB,SAAnB,EAA8B,MAA9B;AACD;;AACD;AACD;;AACD;AACE,UAAA,KAAI,CAAC,gBAAL,CAAsB,SAAtB,EAAiC,OAAO,CAAC,MAAR,CAAe,MAAhD;;AA1BJ;AA4BD,KA3CO;;AA6CA,IAAA,KAAA,CAAA,YAAA,GAAe,YAAA;;;AACrB,MAAA,KAAI,CAAC,sBAAL,CAA4B,KAA5B;;AACM,UAAA,EAAA,GAA0B,eAAe,EAAzC;AAAA,UAAE,MAAM,GAAA,EAAA,CAAA,MAAR;AAAA,UAAU,WAAW,GAAA,EAAA,CAAA,WAArB;;AACN,MAAA,KAAI,CAAC,cAAL,GAAsB,MAAtB;;qCACW,Y,EAAY;AACrB,SAAC,YAAA;AAAA,iBAAA,SAAA,CAAA,KAAA,EAAA,KAAA,CAAA,EAAA,KAAA,CAAA,EAAA,YAAA;;;;;;;AAEG,yBAAA,CAAA;AAAA;AAAA,oBAAM,KAAK,sBAAL,CAA4B,WAA5B,EAAyC,YAAzC,CAAN,CAAA;;;AAAA,kBAAA,EAAA,CAAA,IAAA;;;;;;;;;AAEA,sBAAI,CAAC,WAAW,EAAhB,EAAoB;AAClB,oBAAA,OAAO,CAAC,KAAR,CACE,+BAA4B,YAAY,CAAC,MAAb,CAAoB,CAApB,CAA5B,GAAkD,8CADpD,EAEE,OAFF;AAID;;;;;;;;;;;;WATJ,CAAA;AAWA,SAXD;;;;AADF,aAA2B,IAAA,EAAA,GAAA,QAAA,CAAA,KAAI,CAAC,wBAAL,CAA8B,MAA9B,EAAA,CAAA,EAAsC,EAAA,GAAA,EAAA,CAAA,IAAA,EAAjE,EAAiE,CAAA,EAAA,CAAA,IAAjE,EAAiE,EAAA,GAAA,EAAA,CAAA,IAAA,EAAjE,EAAiE;AAA5D,cAAM,YAAY,GAAA,EAAA,CAAA,KAAlB;;kBAAM,Y;AAaV;;;;;;;;;;;;;AACD,MAAA,KAAI,CAAC,cAAL;AACD,KAnBO;;AArKN,IAAA,KAAI,CAAC,UAAL,GAAkB,cAAc,CAAC,OAAD,CAAhC;;AACA,IAAA,KAAI,CAAC,kBAAL;;AACA,IAAA,KAAI,CAAC,cAAL;;;AACD;;AAEM,EAAA,wBAAA,CAAA,SAAA,CAAA,IAAA,GAAP,UACE,OADF,EAEE,QAFF,EAEkE;AAEhE,QAAI,kBAAkB,CAAC,OAAD,CAAtB,EAAiC;AACvB,UAAA,EAAE,GAAK,OAAO,CAAZ,EAAF;;AACR,UAAI,EAAE,KAAK,SAAX,EAAsB;AACpB;AACA;AACD;;AACD,MAAA,YAAY,CAAC,KAAK,SAAL,CAAe,OAAf,CAAD,EAA0B,QAA1B,CAAZ;AACA;AACD;;AACD,QAAI,oBAAoB,CAAC,OAAD,CAAxB,EAAmC;AACjC,MAAA,YAAY,CAAC,KAAK,WAAL,CAAiB,OAAjB,CAAD,EAA4B,QAA5B,CAAZ;AACA;AACD;;AACD,IAAA,YAAY,CAAC,KAAK,WAAL,CAAiB,OAAjB,CAAD,EAA4B,QAA5B,CAAZ;AACD,GAlBM;;AAoBA,EAAA,wBAAA,CAAA,SAAA,CAAA,qBAAA,GAAP,YAAA;AACE,WAAO,IAAP;AACD,GAFM;;AAIA,EAAA,wBAAA,CAAA,SAAA,CAAA,UAAA,GAAP,UAAkB,IAAlB,EAAiC,MAAjC,EAAgD;AAC9C,SAAK,qBAAL;AACA,SAAK,kBAAL;AACA,SAAK,wBAAL;AACA,SAAK,EAAL,CAAQ,KAAR,CAAc,IAAd,EAAoB,MAApB;AACD,GALM;;AAOA,EAAA,wBAAA,CAAA,SAAA,CAAA,OAAA,GAAP,YAAA,CACE;AACA;AACD,GAHM;;AAKA,EAAA,wBAAA,CAAA,SAAA,CAAA,KAAA,GAAP,YAAA,CACE;AACD,GAFM;;AAIA,EAAA,wBAAA,CAAA,SAAA,CAAA,SAAA,GAAP,YAAA,CACE;AACD,GAFM;;AAIO,EAAA,wBAAA,CAAA,SAAA,CAAA,SAAA,GAAd,UAAwB,OAAxB,EAA+C;;;;;;;AACrC,YAAA,MAAM,GAAkB,OAAO,CAAzB,MAAN,EAAQ,EAAA,GAAgB,OAAO,CAAZ,MAAnB,EAAQ,MAAM,GAAA,EAAA,KAAA,KAAA,CAAA,GAAG,EAAH,GAAK,EAAnB;AACoB,mBAAA,CAAA;AAAA;AAAA,cAAM,KAAK,cAAL,EAAN,CAAA;;;AAAtB,YAAA,mBAAmB,GAAG,EAAA,CAAA,IAAA,EAAtB;AACW,mBAAA,CAAA;AAAA;AAAA,cAAM,KAAK,WAAL,CAAiB,OAAjB,CAAN,CAAA;;;AAAX,YAAA,QAAQ,GAAG,EAAA,CAAA,IAAA,EAAX;AACA,YAAA,EAAE,GAAG,QAAQ,CAAC,MAAd;AACN,iBAAK,wBAAL,CAA8B,GAA9B,CAAkC,EAAlC,EAAsC;AACpC,cAAA,MAAM,EAAA,MAD8B;AAEpC,cAAA,MAAM,EAAA,MAF8B;AAGpC,cAAA,mBAAmB,EAAA,mBAHiB;AAIpC,cAAA,SAAS,EAAE,EAJyB;AAKpC,cAAA,UAAU,EAAE,EALwB;AAMpC,cAAA,UAAU,EAAE,EANwB;AAOpC,cAAA,aAAa,EAAE,KAPqB;AAQpC,cAAA,cAAc,EAAE;AARoB,aAAtC;AAUA,iBAAK,sBAAL,CAA4B,GAA5B,CAAgC,EAAhC,EAAoC,EAApC;AACA,mBAAA,CAAA;AAAA;AAAA,cAAO,YAAY,CAAC,OAAO,CAAC,EAAT,EAAc,EAAd,CAAnB,CAAA;;;;AACD,GAjBa;;AAmBA,EAAA,wBAAA,CAAA,SAAA,CAAA,WAAA,GAAd,UAA0B,OAA1B,EAAiD;;;;;;;;AACzC,YAAA,cAAc,GAAA,CAAA,EAAA,GAAG,OAAO,CAAC,MAAX,MAAiB,IAAjB,IAAiB,EAAA,KAAA,KAAA,CAAjB,GAAiB,KAAA,CAAjB,GAAiB,EAAA,CAAG,CAAH,CAA/B;AACA,YAAA,mBAAmB,GAAG,KAAK,wBAAL,CAA8B,GAA9B,CAC1B,cAD0B,CAAtB;;AAGN,gBAAI,CAAC,mBAAL,EAA0B;AACxB,qBAAA,CAAA;AAAA;AAAA,gBAAO,YAAY,CAAC,OAAO,CAAC,EAAT,EAAc,KAAd,CAAnB,CAAA;AACD;;AACO,YAAA,UAAU,GAAK,mBAAmB,CAAxB,UAAV;AACF,YAAA,eAAe,GAAA,QAAA,CAAA,QAAA,CAAA,EAAA,EAAQ,OAAR,CAAA,EAAe;AAAE,cAAA,MAAM,EAAE,CAAC,UAAD;AAAV,aAAf,CAAf;AACN,mBAAA,CAAA;AAAA;AAAA,cAAM,KAAK,WAAL,CAAiB,eAAjB,CAAN,CAAA;;;AAAA,YAAA,EAAA,CAAA,IAAA;;AACA,iBAAK,wBAAL,CAA8B,MAA9B,CAAqC,cAArC;AACA,iBAAK,sBAAL,CAA4B,MAA5B,CAAmC,UAAnC;AACA,mBAAA,CAAA;AAAA;AAAA,cAAO,YAAY,CAAC,OAAO,CAAC,EAAT,EAAc,IAAd,CAAnB,CAAA;;;;AACD,GAda;;AAgBN,EAAA,wBAAA,CAAA,SAAA,CAAA,kBAAA,GAAR,YAAA;AACE,SAAK,EAAL,CAAQ,gBAAR,CAAyB,SAAzB,EAAoC,KAAK,aAAzC;AACA,SAAK,EAAL,CAAQ,gBAAR,CAAyB,QAAzB,EAAmC,KAAK,YAAxC;AACA,SAAK,EAAL,CAAQ,gBAAR,CAAyB,MAAzB,EAAiC,KAAK,wBAAtC;AACD,GAJO;;AAMA,EAAA,wBAAA,CAAA,SAAA,CAAA,qBAAA,GAAR,YAAA;AACE,SAAK,EAAL,CAAQ,mBAAR,CAA4B,SAA5B,EAAuC,KAAK,aAA5C;AACA,SAAK,EAAL,CAAQ,mBAAR,CAA4B,QAA5B,EAAsC,KAAK,YAA3C;AACA,SAAK,EAAL,CAAQ,mBAAR,CAA4B,MAA5B,EAAoC,KAAK,wBAAzC;AACD,GAJO;;AAgGM,EAAA,wBAAA,CAAA,SAAA,CAAA,sBAAA,GAAd,UACE,WADF,EAEE,YAFF,EAEmC;;;;;;;;;AAG/B,YAAA,SAAS,GAMP,YAAY,CANL,SAAT,EACA,MAAM,GAKJ,YAAY,CALR,MADN,EAEA,MAAM,GAIJ,YAAY,CAJR,MAFN,EAGA,UAAU,GAGR,YAAY,CAHJ,UAHV,EAIA,cAAc,GAEZ,YAAY,CAFA,cAJd,EAKA,mBAAmB,GACjB,YAAY,CADK,mBALnB;AAOF,YAAA,YAAY,CAAC,aAAb,GAA6B,IAA7B;AACA,YAAA,cAAc,CAAC,MAAf,GAAwB,CAAxB;;;;;;AAEqB,mBAAA,CAAA;AAAA;AAAA,cAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,MAAlB,EAA0B,MAA1B,CAAN,CAAA;;;AAAb,YAAA,UAAU,GAAG,EAAA,CAAA,IAAA,EAAb;AACN,YAAA,gBAAgB,CAAC,WAAD,CAAhB;AACA,YAAA,YAAY,CAAC,UAAb,GAA0B,UAA1B;AACA,iBAAK,sBAAL,CAA4B,GAA5B,CAAgC,UAAhC,EAA4C,SAA5C;AACQ,YAAA,EAAA,GAAA,MAAM,CAAC,CAAD,CAAN;;;mBACD,U;AAAA,uBAAA,CAAA;AAAA;AAAA,kBAAA,CAAA,CAAA;;mBAmBA,M;AAAA,uBAAA,CAAA;AAAA;AAAA,kBAAA,CAAA,CAAA;;;;;;;;AAlBoB,mBAAA,CAAA;AAAA;AAAA,cAAM,kBAAkB,CAC7C,YAAA;AACE,qBAAA,WAAW,CACT,KAAI,CAAC,UAAL,CAAgB,mBAAhB,CACE,WADF,EAEE,UAFF,EAGE,mBAHF,CADS,EAMT,gBANS,CAAX;AAOC,aAT0C,EAU7C,gBAV6C,EAW7C,YAAA;AAAM,qBAAA,CAAC,WAAD,EAAA;AAAc,aAXyB,CAAxB,CAAA;;;AAAjB,YAAA,cAAc,GAAG,EAAA,CAAA,IAAA,EAAjB;AAaN,YAAA,gBAAgB,CAAC,WAAD,CAAhB;AACM,YAAA,MAAM,GAAG,cAAc,CAAA,QAAA,CAAK,cAAL,EAAwB,cAAxB,CAAA,CAAvB;AACN,YAAA,MAAM,CAAC,OAAP,CAAe,UAAC,KAAD,EAAM;AAAK,qBAAA,KAAI,CAAC,iBAAL,CAAuB,SAAvB,EAAA,KAAA,CAAA;AAAwC,aAAlE;AACA,mBAAA,CAAA;AAAA;AAAA,cAAA,CAAA,CAAA;;;AAGM,YAAA,QAAA,GAAiC,MAAM,CAAC,CAAD,CAAN,IAAa,EAA9C;AACiB,mBAAA,CAAA;AAAA;AAAA,cAAM,kBAAkB,CAC7C,YAAA;AACE,qBAAA,WAAW,CACT,KAAI,CAAC,UAAL,CAAgB,eAAhB,CACE,WADF,EAEE,QAFF,EAGE,UAHF,EAIE,mBAJF,CADS,EAOT,gBAPS,CAAX;AAQC,aAV0C,EAW7C,gBAX6C,EAY7C,YAAA;AAAM,qBAAA,CAAC,WAAD,EAAA;AAAc,aAZyB,CAAxB,CAAA;;;AAAjB,YAAA,cAAc,GAAG,EAAA,CAAA,IAAA,EAAjB;AAcN,YAAA,gBAAgB,CAAC,WAAD,CAAhB;AACM,YAAA,MAAM,GAAG,UAAU,CAAA,QAAA,CAAK,cAAL,EAAwB,cAAxB,CAAA,CAAnB;AACN,YAAA,MAAM,CAAC,OAAP,CAAe,UAAC,KAAD,EAAM;AAAK,qBAAA,KAAI,CAAC,aAAL,CAAmB,SAAnB,EAAA,KAAA,CAAA;AAAoC,aAA9D;AACA,mBAAA,CAAA;AAAA;AAAA,cAAA,CAAA,CAAA;;;AAGA,mBAAA,CAAA;AAAA;AAAA,cAAA,CAAA,CAAA;;;;;;;;AAGJ,YAAA,YAAY,CAAC,aAAb,GAA6B,KAA7B;AACA,YAAA,cAAc,CAAC,MAAf,GAAwB,CAAxB;;;;;;;;;;;;AAEH,GAnEa;;AAqEA,EAAA,wBAAA,CAAA,SAAA,CAAA,cAAA,GAAd,YAAA;;;;;;AACiC,mBAAA,CAAA;AAAA;AAAA,cAAM,KAAK,OAAL,CAAa,IAAb,CAAkB,iBAAlB,CAAN,CAAA;;;AAAzB,YAAA,cAAc,GAAW,EAAA,CAAA,IAAA,EAAzB;AACN,mBAAA,CAAA;AAAA;AAAA,cAAO,OAAO,CAAC,cAAD,CAAd,CAAA;;;;AACD,GAHa;;AAKN,EAAA,wBAAA,CAAA,SAAA,CAAA,iBAAA,GAAR,UAA0B,SAA1B,EAA6C,MAA7C,EAAkE;AAChE,SAAK,oBAAL,CAA0B,SAA1B,EAAqC,MAArC,EAA6C,sBAA7C;AACD,GAFO;;AAIA,EAAA,wBAAA,CAAA,SAAA,CAAA,aAAA,GAAR,UAAsB,SAAtB,EAAyC,MAAzC,EAA0D;AACxD,SAAK,oBAAL,CAA0B,SAA1B,EAAqC,MAArC,EAA6C,kBAA7C;AACD,GAFO;AAIR;;;;AAIG;;;AACK,EAAA,wBAAA,CAAA,SAAA,CAAA,oBAAA,GAAR,UACE,SADF,EAEE,MAFF,EAGE,cAHF,EAGuC;AAErC,QAAM,YAAY,GAAG,KAAK,wBAAL,CAA8B,GAA9B,CAAkC,SAAlC,CAArB;;AACA,QAAI,CAAC,YAAL,EAAmB;AACjB;AACD,KALoC,CAMrC;AACA;AACA;;;AACA,IAAA,qBAAqB,CACnB,YAAY,CAAC,UADM,EACI,QAAA,CAAA,EAAA,EAClB,MADkB,CADJ,EAGnB,cAHmB,CAArB;AAKA,SAAK,gBAAL,CAAsB,SAAtB,EAAiC,MAAjC;AACD,GAlBO;;AAoBA,EAAA,wBAAA,CAAA,SAAA,CAAA,gBAAA,GAAR,UAAyB,SAAzB,EAA4C,MAA5C,EAAuD;AACrD,QAAM,KAAK,GAAsB;AAC/B,MAAA,OAAO,EAAE,KADsB;AAE/B,MAAA,MAAM,EAAE,kBAFuB;AAG/B,MAAA,MAAM,EAAE;AACN,QAAA,YAAY,EAAE,SADR;AAEN,QAAA,MAAM,EAAA;AAFA;AAHuB,KAAjC;AAQA,SAAK,IAAL,CAAU,MAAV,EAAkB,KAAlB;AACD,GAVO;;AAWV,SAAA,wBAAA;AAAC,CAxUD,CACU,YADV,CAAA;;;;AA0UA,SAAS,yBAAT,CACE,UADF,EAEE,KAFF,EAEsB;AAEpB,EAAA,qBAAqB,CAAC,UAAD,EAAa,KAAb,EAAoB,sBAApB,CAArB;AACD;;AAED,SAAS,qBAAT,CACE,UADF,EAEE,KAFF,EAEkB;AAEhB,EAAA,qBAAqB,CAAC,UAAD,EAAa,KAAb,EAAoB,kBAApB,CAArB;AACD;AAED;;;AAGG;;;AACH,SAAS,qBAAT,CACE,UADF,EAEE,KAFF,EAGE,cAHF,EAGsC;AAEpC,MAAM,kBAAkB,GAAG,cAAc,CAAC,KAAD,CAAzC,CAFoC,CAGpC;AACA;;AACA,MAAM,cAAc,GAAG,UAAU,CAAC,SAAX,CACrB,UAAC,CAAD,EAAE;AAAK,WAAA,cAAc,CAAC,CAAD,CAAd,GAAoB,kBAAkB,GAAtC,0BAAA;AAAmE,GADrD,CAAvB;;AAGA,MAAI,cAAc,KAAK,CAAC,CAAxB,EAA2B;AACzB,IAAA,UAAU,CAAC,MAAX,GAAoB,CAApB;AACD,GAFD,MAEO;AACL,IAAA,UAAU,CAAC,MAAX,CAAkB,CAAlB,EAAqB,cAArB;AACD;;AACD,EAAA,UAAU,CAAC,IAAX,CAAgB,KAAhB;AACD;;AAED,SAAS,kBAAT,CACE,OADF,EAC+B;AAE7B,SAAO,CAAC,KAAK,CAAC,OAAN,CAAc,OAAd,CAAD,IAA2B,OAAO,CAAC,MAAR,KAAmB,eAArD;AACD;;AAED,SAAS,oBAAT,CACE,OADF,EAC+B;AAE7B,SAAO,CAAC,KAAK,CAAC,OAAN,CAAc,OAAd,CAAD,IAA2B,OAAO,CAAC,MAAR,KAAmB,iBAArD;AACD;;AAED,SAAS,sBAAT,CAAgC,KAAhC,EAAoD;AAClD,SAAO,OAAO,CAAC,KAAK,CAAC,MAAP,CAAd;AACD;;AAED,SAAS,kBAAT,CAA4B,KAA5B,EAA4C;AAC1C,SAAO,OAAO,CAAC,KAAK,CAAC,WAAP,CAAd;AACD;;AAED,SAAS,IAAT,GAAa,CACX;AACD","sourcesContent":["import EventEmitter from \"eventemitter3\";\nimport SturdyWebSocket from \"sturdy-websocket\";\nimport {\n  Backfiller,\n  dedupeLogs,\n  dedupeNewHeads,\n  LogsEvent,\n  LogsSubscriptionFilter,\n  makeBackfiller,\n  NewHeadsEvent,\n} from \"../subscriptions/subscriptionBackfill\";\nimport {\n  isSubscriptionEvent,\n  JsonRpcRequest,\n  JsonRpcResponse,\n  SingleOrBatchRequest,\n  SingleOrBatchResponse,\n  SubscriptionEvent,\n  WebSocketMessage,\n} from \"../types\";\nimport { fromHex } from \"../util/hex\";\nimport { JsonRpcSenders, makeResponse } from \"../util/jsonRpc\";\nimport {\n  callWhenDone,\n  makeCancelToken,\n  throwIfCancelled,\n  withBackoffRetries,\n  withTimeout,\n} from \"../util/promises\";\nimport { SendPayloadFunction } from \"./sendPayload\";\n\nconst HEARTBEAT_INTERVAL = 30000;\nconst HEARTBEAT_WAIT_TIME = 10000;\nconst BACKFILL_TIMEOUT = 60000;\nconst BACKFILL_RETRIES = 5;\n/**\n * Subscriptions have a memory of recent events they have sent so that in the\n * event that they disconnect and need to backfill, they can detect re-orgs.\n * Keep a buffer that goes back at least these many blocks, the maximum amount\n * at which we might conceivably see a re-org.\n *\n * Note that while our buffer goes back this many blocks, it may contain more\n * than this many elements, since in the case of logs subscriptions more than\n * one event may be emitted for a block.\n */\nconst RETAINED_EVENT_BLOCK_COUNT = 10;\n\n/**\n * This is the undocumented interface required by Web3 for providers which\n * handle subscriptions.\n *\n * In addition to the stated methods here, it communicates subscription events\n * by using `EventEmitter#emit(\"data\", event)` to emit the events.\n */\nexport interface Web3SubscriptionProvider extends EventEmitter {\n  send(\n    payload: SingleOrBatchRequest,\n    callback: (error: any, response?: SingleOrBatchResponse) => void,\n  ): void;\n  disconnect(code?: number, reason?: string): void;\n  supportsSubscriptions(): true;\n  connect(): void;\n  reset(): void;\n  reconnect(): void;\n}\n\ninterface VirtualSubscription {\n  virtualId: string;\n  physicalId: string;\n  method: string;\n  params: any[];\n  isBackfilling: boolean;\n  startingBlockNumber: number;\n  sentEvents: any[];\n  backfillBuffer: any[];\n}\n\ninterface NewHeadsSubscription extends VirtualSubscription {\n  method: \"eth_subscribe\";\n  params: [\"newHeads\"];\n  isBackfilling: boolean;\n  sentEvents: NewHeadsEvent[];\n  backfillBuffer: NewHeadsEvent[];\n}\n\ninterface LogsSubscription extends VirtualSubscription {\n  method: \"eth_subscribe\";\n  params: [\"logs\", LogsSubscriptionFilter?];\n  isBackfilling: boolean;\n  sentEvents: LogsEvent[];\n  backfillBuffer: LogsEvent[];\n}\n\nexport class AlchemyWebSocketProvider\n  extends EventEmitter\n  implements Web3SubscriptionProvider {\n  // In the case of a WebSocket reconnection, all subscriptions are lost and we\n  // create new ones to replace them, but we want to create the illusion that\n  // the original subscriptions persist. Thus, maintain a mapping from the\n  // \"virtual\" subscription ids which are visible to the consumer to the\n  // \"physical\" subscription ids of the actual connections. This terminology is\n  // borrowed from virtual and physical memory, which has a similar mapping.\n  private readonly virtualSubscriptionsById: Map<\n    string,\n    VirtualSubscription\n  > = new Map();\n  private readonly virtualIdsByPhysicalId: Map<string, string> = new Map();\n  private readonly backfiller: Backfiller;\n  private heartbeatIntervalId?: NodeJS.Timeout;\n  private cancelBackfill = noop;\n\n  constructor(\n    private readonly ws: SturdyWebSocket,\n    private readonly sendPayload: SendPayloadFunction,\n    private readonly senders: JsonRpcSenders,\n  ) {\n    super();\n    this.backfiller = makeBackfiller(senders);\n    this.addSocketListeners();\n    this.startHeartbeat();\n  }\n\n  public send(\n    request: SingleOrBatchRequest,\n    callback: (error: any, response?: SingleOrBatchResponse) => void,\n  ): void {\n    if (isSubscribeRequest(request)) {\n      const { id } = request;\n      if (id === undefined) {\n        // The JSON-RPC spec says to return nothing if there is no request id.\n        return;\n      }\n      callWhenDone(this.subscribe(request), callback);\n      return;\n    }\n    if (isUnsubscribeRequest(request)) {\n      callWhenDone(this.unsubscribe(request), callback);\n      return;\n    }\n    callWhenDone(this.sendPayload(request), callback);\n  }\n\n  public supportsSubscriptions(): true {\n    return true;\n  }\n\n  public disconnect(code?: number, reason?: string): void {\n    this.removeSocketListeners();\n    this.removeAllListeners();\n    this.stopHeartbeatAndBackfill();\n    this.ws.close(code, reason);\n  }\n\n  public connect(): void {\n    // No-op. We're already connected when passed a websocket in the\n    // constructor.\n  }\n\n  public reset(): void {\n    // No-op.\n  }\n\n  public reconnect(): void {\n    // No-op. This isn't called anywhere.\n  }\n\n  private async subscribe(request: JsonRpcRequest): Promise<JsonRpcResponse> {\n    const { method, params = [] } = request;\n    const startingBlockNumber = await this.getBlockNumber();\n    const response = await this.sendPayload(request);\n    const id = response.result;\n    this.virtualSubscriptionsById.set(id, {\n      method,\n      params,\n      startingBlockNumber,\n      virtualId: id,\n      physicalId: id,\n      sentEvents: [],\n      isBackfilling: false,\n      backfillBuffer: [],\n    });\n    this.virtualIdsByPhysicalId.set(id, id);\n    return makeResponse(request.id!, id);\n  }\n\n  private async unsubscribe(request: JsonRpcRequest): Promise<JsonRpcResponse> {\n    const subscriptionId = request.params?.[0];\n    const virtualSubscription = this.virtualSubscriptionsById.get(\n      subscriptionId,\n    );\n    if (!virtualSubscription) {\n      return makeResponse(request.id!, false);\n    }\n    const { physicalId } = virtualSubscription;\n    const physicalRequest = { ...request, params: [physicalId] };\n    await this.sendPayload(physicalRequest);\n    this.virtualSubscriptionsById.delete(subscriptionId);\n    this.virtualIdsByPhysicalId.delete(physicalId);\n    return makeResponse(request.id!, true);\n  }\n\n  private addSocketListeners(): void {\n    this.ws.addEventListener(\"message\", this.handleMessage);\n    this.ws.addEventListener(\"reopen\", this.handleReopen);\n    this.ws.addEventListener(\"down\", this.stopHeartbeatAndBackfill);\n  }\n\n  private removeSocketListeners(): void {\n    this.ws.removeEventListener(\"message\", this.handleMessage);\n    this.ws.removeEventListener(\"reopen\", this.handleReopen);\n    this.ws.removeEventListener(\"down\", this.stopHeartbeatAndBackfill);\n  }\n\n  private startHeartbeat = (): void => {\n    if (this.heartbeatIntervalId != null) {\n      return;\n    }\n    this.heartbeatIntervalId = setInterval(async () => {\n      try {\n        await withTimeout(\n          this.senders.send(\"net_version\"),\n          HEARTBEAT_WAIT_TIME,\n        );\n      } catch {\n        this.ws.reconnect();\n      }\n    }, HEARTBEAT_INTERVAL);\n  };\n\n  private stopHeartbeatAndBackfill = (): void => {\n    if (this.heartbeatIntervalId != null) {\n      clearInterval(this.heartbeatIntervalId);\n      this.heartbeatIntervalId = undefined;\n    }\n    this.cancelBackfill();\n  };\n\n  private handleMessage = (event: MessageEvent): void => {\n    const message: WebSocketMessage = JSON.parse(event.data);\n    if (!isSubscriptionEvent(message)) {\n      return;\n    }\n    const physicalId = message.params.subscription;\n    const virtualId = this.virtualIdsByPhysicalId.get(physicalId);\n    if (!virtualId) {\n      return;\n    }\n    const subscription = this.virtualSubscriptionsById.get(virtualId)!;\n    if (subscription.method !== \"eth_subscribe\") {\n      this.emitGenericEvent(virtualId, message.params.result);\n      return;\n    }\n    switch (subscription.params[0]) {\n      case \"newHeads\": {\n        const newHeadsSubscription = subscription as NewHeadsSubscription;\n        const newHeadsMessage = message as SubscriptionEvent<NewHeadsEvent>;\n        const { isBackfilling, backfillBuffer } = newHeadsSubscription;\n        const { result } = newHeadsMessage.params;\n        if (isBackfilling) {\n          addToNewHeadsEventsBuffer(backfillBuffer, result);\n        } else {\n          this.emitNewHeadsEvent(virtualId, result);\n        }\n        break;\n      }\n      case \"logs\": {\n        const logsSubscription = subscription as LogsSubscription;\n        const logsMessage = message as SubscriptionEvent<LogsEvent>;\n        const { isBackfilling, backfillBuffer } = logsSubscription;\n        const { result } = logsMessage.params;\n        if (isBackfilling) {\n          addToLogsEventsBuffer(backfillBuffer, result);\n        } else {\n          this.emitLogsEvent(virtualId, result);\n        }\n        break;\n      }\n      default:\n        this.emitGenericEvent(virtualId, message.params.result);\n    }\n  };\n\n  private handleReopen = (): void => {\n    this.virtualIdsByPhysicalId.clear();\n    const { cancel, isCancelled } = makeCancelToken();\n    this.cancelBackfill = cancel;\n    for (const subscription of this.virtualSubscriptionsById.values()) {\n      (async () => {\n        try {\n          await this.resubscribeAndBackfill(isCancelled, subscription);\n        } catch (error) {\n          if (!isCancelled()) {\n            console.error(\n              `Error while backfilling \"${subscription.params[0]}\" subscription. Some events may be missing.`,\n              error,\n            );\n          }\n        }\n      })();\n    }\n    this.startHeartbeat();\n  };\n\n  private async resubscribeAndBackfill(\n    isCancelled: () => boolean,\n    subscription: VirtualSubscription,\n  ): Promise<void> {\n    const {\n      virtualId,\n      method,\n      params,\n      sentEvents,\n      backfillBuffer,\n      startingBlockNumber,\n    } = subscription;\n    subscription.isBackfilling = true;\n    backfillBuffer.length = 0;\n    try {\n      const physicalId = await this.senders.send(method, params);\n      throwIfCancelled(isCancelled);\n      subscription.physicalId = physicalId;\n      this.virtualIdsByPhysicalId.set(physicalId, virtualId);\n      switch (params[0]) {\n        case \"newHeads\": {\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getNewHeadsBackfill(\n                  isCancelled,\n                  sentEvents,\n                  startingBlockNumber,\n                ),\n                BACKFILL_TIMEOUT,\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled(),\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeNewHeads([...backfillEvents, ...backfillBuffer]);\n          events.forEach((event) => this.emitNewHeadsEvent(virtualId, event));\n          break;\n        }\n        case \"logs\": {\n          const filter: LogsSubscriptionFilter = params[1] || {};\n          const backfillEvents = await withBackoffRetries(\n            () =>\n              withTimeout(\n                this.backfiller.getLogsBackfill(\n                  isCancelled,\n                  filter,\n                  sentEvents,\n                  startingBlockNumber,\n                ),\n                BACKFILL_TIMEOUT,\n              ),\n            BACKFILL_RETRIES,\n            () => !isCancelled(),\n          );\n          throwIfCancelled(isCancelled);\n          const events = dedupeLogs([...backfillEvents, ...backfillBuffer]);\n          events.forEach((event) => this.emitLogsEvent(virtualId, event));\n          break;\n        }\n        default:\n          break;\n      }\n    } finally {\n      subscription.isBackfilling = false;\n      backfillBuffer.length = 0;\n    }\n  }\n\n  private async getBlockNumber(): Promise<number> {\n    const blockNumberHex: string = await this.senders.send(\"eth_blockNumber\");\n    return fromHex(blockNumberHex);\n  }\n\n  private emitNewHeadsEvent(virtualId: string, result: NewHeadsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getNewHeadsBlockNumber);\n  }\n\n  private emitLogsEvent(virtualId: string, result: LogsEvent): void {\n    this.emitAndRememberEvent(virtualId, result, getLogsBlockNumber);\n  }\n\n  /**\n   * Emits an event to consumers, but also remembers it in its subscriptions's\n   * `sentEvents` buffer so that we can detect re-orgs if the connection drops\n   * and needs to be reconnected.\n   */\n  private emitAndRememberEvent<T>(\n    virtualId: string,\n    result: T,\n    getBlockNumber: (result: T) => number,\n  ): void {\n    const subscription = this.virtualSubscriptionsById.get(virtualId);\n    if (!subscription) {\n      return;\n    }\n    // Web3 modifies these event objects once we pass them on (changing hex\n    // numbers to numbers). We want the original event, so make a defensive\n    // copy.\n    addToPastEventsBuffer(\n      subscription.sentEvents,\n      { ...result },\n      getBlockNumber,\n    );\n    this.emitGenericEvent(virtualId, result);\n  }\n\n  private emitGenericEvent(virtualId: string, result: any): void {\n    const event: SubscriptionEvent = {\n      jsonrpc: \"2.0\",\n      method: \"eth_subscription\",\n      params: {\n        subscription: virtualId,\n        result,\n      },\n    };\n    this.emit(\"data\", event);\n  }\n}\n\nfunction addToNewHeadsEventsBuffer(\n  pastEvents: NewHeadsEvent[],\n  event: NewHeadsEvent,\n): void {\n  addToPastEventsBuffer(pastEvents, event, getNewHeadsBlockNumber);\n}\n\nfunction addToLogsEventsBuffer(\n  pastEvents: LogsEvent[],\n  event: LogsEvent,\n): void {\n  addToPastEventsBuffer(pastEvents, event, getLogsBlockNumber);\n}\n\n/**\n * Adds a new event to an array of events, evicting any events which\n * are so old that they will no longer feasibly be part of a reorg.\n */\nfunction addToPastEventsBuffer<T>(\n  pastEvents: T[],\n  event: T,\n  getBlockNumber: (event: T) => number,\n): void {\n  const currentBlockNumber = getBlockNumber(event);\n  // Find first index of an event recent enough to retain, then drop everything\n  // at a lower index.\n  const firstGoodIndex = pastEvents.findIndex(\n    (e) => getBlockNumber(e) > currentBlockNumber - RETAINED_EVENT_BLOCK_COUNT,\n  );\n  if (firstGoodIndex === -1) {\n    pastEvents.length = 0;\n  } else {\n    pastEvents.splice(0, firstGoodIndex);\n  }\n  pastEvents.push(event);\n}\n\nfunction isSubscribeRequest(\n  request: SingleOrBatchRequest,\n): request is JsonRpcRequest {\n  return !Array.isArray(request) && request.method === \"eth_subscribe\";\n}\n\nfunction isUnsubscribeRequest(\n  request: SingleOrBatchRequest,\n): request is JsonRpcRequest {\n  return !Array.isArray(request) && request.method === \"eth_unsubscribe\";\n}\n\nfunction getNewHeadsBlockNumber(event: NewHeadsEvent): number {\n  return fromHex(event.number);\n}\n\nfunction getLogsBlockNumber(event: LogsEvent): number {\n  return fromHex(event.blockNumber);\n}\n\nfunction noop(): void {\n  // Nothing.\n}\n"],"sourceRoot":""},"metadata":{},"sourceType":"module"}