{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar SHOULD_RECONNECT_FALSE_MESSAGE = \"Provided shouldReconnect() returned false. Closing permanently.\";\nvar SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE = \"Provided shouldReconnect() resolved to false. Closing permanently.\";\n\nvar SturdyWebSocket =\n/** @class */\nfunction () {\n  function SturdyWebSocket(url, protocolsOrOptions, options) {\n    if (options === void 0) {\n      options = {};\n    }\n\n    this.url = url;\n    this.onclose = null;\n    this.onerror = null;\n    this.onmessage = null;\n    this.onopen = null;\n    this.ondown = null;\n    this.onreopen = null;\n    this.CONNECTING = SturdyWebSocket.CONNECTING;\n    this.OPEN = SturdyWebSocket.OPEN;\n    this.CLOSING = SturdyWebSocket.CLOSING;\n    this.CLOSED = SturdyWebSocket.CLOSED;\n    this.hasBeenOpened = false;\n    this.isClosed = false;\n    this.messageBuffer = [];\n    this.nextRetryTime = 0;\n    this.reconnectCount = 0;\n    this.lastKnownExtensions = \"\";\n    this.lastKnownProtocol = \"\";\n    this.listeners = {};\n\n    if (protocolsOrOptions == null || typeof protocolsOrOptions === \"string\" || Array.isArray(protocolsOrOptions)) {\n      this.protocols = protocolsOrOptions;\n    } else {\n      options = protocolsOrOptions;\n    }\n\n    this.options = applyDefaultOptions(options);\n\n    if (!this.options.wsConstructor) {\n      if (typeof WebSocket !== \"undefined\") {\n        this.options.wsConstructor = WebSocket;\n      } else {\n        throw new Error(\"WebSocket not present in global scope and no \" + \"wsConstructor option was provided.\");\n      }\n    }\n\n    this.openNewWebSocket();\n  }\n\n  Object.defineProperty(SturdyWebSocket.prototype, \"binaryType\", {\n    get: function get() {\n      return this.binaryTypeInternal || \"blob\";\n    },\n    set: function set(binaryType) {\n      this.binaryTypeInternal = binaryType;\n\n      if (this.ws) {\n        this.ws.binaryType = binaryType;\n      }\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SturdyWebSocket.prototype, \"bufferedAmount\", {\n    get: function get() {\n      var sum = this.ws ? this.ws.bufferedAmount : 0;\n      var hasUnknownAmount = false;\n      this.messageBuffer.forEach(function (data) {\n        var byteLength = getDataByteLength(data);\n\n        if (byteLength != null) {\n          sum += byteLength;\n        } else {\n          hasUnknownAmount = true;\n        }\n      });\n\n      if (hasUnknownAmount) {\n        this.debugLog(\"Some buffered data had unknown length. bufferedAmount()\" + \" return value may be below the correct amount.\");\n      }\n\n      return sum;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SturdyWebSocket.prototype, \"extensions\", {\n    get: function get() {\n      return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SturdyWebSocket.prototype, \"protocol\", {\n    get: function get() {\n      return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n    },\n    enumerable: true,\n    configurable: true\n  });\n  Object.defineProperty(SturdyWebSocket.prototype, \"readyState\", {\n    get: function get() {\n      return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n    },\n    enumerable: true,\n    configurable: true\n  });\n\n  SturdyWebSocket.prototype.close = function (code, reason) {\n    this.disposeSocket(code, reason);\n    this.shutdown();\n    this.debugLog(\"WebSocket permanently closed by client.\");\n  };\n\n  SturdyWebSocket.prototype.send = function (data) {\n    if (this.isClosed) {\n      throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n    } else if (this.ws && this.ws.readyState === this.OPEN) {\n      this.ws.send(data);\n    } else {\n      this.messageBuffer.push(data);\n    }\n  };\n\n  SturdyWebSocket.prototype.reconnect = function () {\n    if (this.isClosed) {\n      throw new Error(\"Cannot call reconnect() on socket which is permanently closed.\");\n    }\n\n    this.disposeSocket(1000, \"Client requested reconnect.\");\n    this.handleClose(undefined);\n  };\n\n  SturdyWebSocket.prototype.addEventListener = function (type, listener) {\n    if (!this.listeners[type]) {\n      this.listeners[type] = [];\n    }\n\n    this.listeners[type].push(listener);\n  };\n\n  SturdyWebSocket.prototype.dispatchEvent = function (event) {\n    return this.dispatchEventOfType(event.type, event);\n  };\n\n  SturdyWebSocket.prototype.removeEventListener = function (type, listener) {\n    if (this.listeners[type]) {\n      this.listeners[type] = this.listeners[type].filter(function (l) {\n        return l !== listener;\n      });\n    }\n  };\n\n  SturdyWebSocket.prototype.openNewWebSocket = function () {\n    var _this = this;\n\n    if (this.isClosed) {\n      return;\n    }\n\n    var _a = this.options,\n        connectTimeout = _a.connectTimeout,\n        wsConstructor = _a.wsConstructor;\n    this.debugLog(\"Opening new WebSocket to \" + this.url + \".\");\n    var ws = new wsConstructor(this.url, this.protocols);\n\n    ws.onclose = function (event) {\n      return _this.handleClose(event);\n    };\n\n    ws.onerror = function (event) {\n      return _this.handleError(event);\n    };\n\n    ws.onmessage = function (event) {\n      return _this.handleMessage(event);\n    };\n\n    ws.onopen = function (event) {\n      return _this.handleOpen(event);\n    };\n\n    this.connectTimeoutId = setTimeout(function () {\n      // If this is running, we still haven't opened the websocket.\n      // Kill it so we can try again.\n      _this.clearConnectTimeout();\n\n      _this.disposeSocket();\n\n      _this.handleClose(undefined);\n    }, connectTimeout);\n    this.ws = ws;\n  };\n\n  SturdyWebSocket.prototype.handleOpen = function (event) {\n    var _this = this;\n\n    if (!this.ws || this.isClosed) {\n      return;\n    }\n\n    var allClearResetTime = this.options.allClearResetTime;\n    this.debugLog(\"WebSocket opened.\");\n\n    if (this.binaryTypeInternal != null) {\n      this.ws.binaryType = this.binaryTypeInternal;\n    } else {\n      this.binaryTypeInternal = this.ws.binaryType;\n    }\n\n    this.clearConnectTimeout();\n\n    if (this.hasBeenOpened) {\n      this.dispatchEventOfType(\"reopen\", event);\n    } else {\n      this.dispatchEventOfType(\"open\", event);\n      this.hasBeenOpened = true;\n    }\n\n    this.messageBuffer.forEach(function (message) {\n      return _this.send(message);\n    });\n    this.messageBuffer = [];\n    this.allClearTimeoutId = setTimeout(function () {\n      _this.clearAllClearTimeout();\n\n      _this.nextRetryTime = 0;\n      _this.reconnectCount = 0;\n      var openTime = allClearResetTime / 1000 | 0;\n\n      _this.debugLog(\"WebSocket remained open for \" + openTime + \" seconds. Resetting\" + \" retry time and count.\");\n    }, allClearResetTime);\n  };\n\n  SturdyWebSocket.prototype.handleMessage = function (event) {\n    if (this.isClosed) {\n      return;\n    }\n\n    this.dispatchEventOfType(\"message\", event);\n  };\n\n  SturdyWebSocket.prototype.handleClose = function (event) {\n    var _this = this;\n\n    if (this.isClosed) {\n      return;\n    }\n\n    var _a = this.options,\n        maxReconnectAttempts = _a.maxReconnectAttempts,\n        shouldReconnect = _a.shouldReconnect;\n    this.clearConnectTimeout();\n    this.clearAllClearTimeout();\n\n    if (this.ws) {\n      this.lastKnownExtensions = this.ws.extensions;\n      this.lastKnownProtocol = this.ws.protocol;\n      this.disposeSocket();\n    }\n\n    this.dispatchEventOfType(\"down\", event);\n\n    if (this.reconnectCount >= maxReconnectAttempts) {\n      this.stopReconnecting(event, this.getTooManyFailedReconnectsMessage());\n      return;\n    }\n\n    var willReconnect = !event || shouldReconnect(event);\n\n    if (typeof willReconnect === \"boolean\") {\n      this.handleWillReconnect(willReconnect, event, SHOULD_RECONNECT_FALSE_MESSAGE);\n    } else {\n      willReconnect.then(function (willReconnectResolved) {\n        if (_this.isClosed) {\n          return;\n        }\n\n        _this.handleWillReconnect(willReconnectResolved, event, SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE);\n      });\n    }\n  };\n\n  SturdyWebSocket.prototype.handleError = function (event) {\n    this.dispatchEventOfType(\"error\", event);\n    this.debugLog(\"WebSocket encountered an error.\");\n  };\n\n  SturdyWebSocket.prototype.handleWillReconnect = function (willReconnect, event, denialReason) {\n    if (willReconnect) {\n      this.reestablishConnection();\n    } else {\n      this.stopReconnecting(event, denialReason);\n    }\n  };\n\n  SturdyWebSocket.prototype.reestablishConnection = function () {\n    var _this = this;\n\n    var _a = this.options,\n        minReconnectDelay = _a.minReconnectDelay,\n        maxReconnectDelay = _a.maxReconnectDelay,\n        reconnectBackoffFactor = _a.reconnectBackoffFactor;\n    this.reconnectCount++;\n    var retryTime = this.nextRetryTime;\n    this.nextRetryTime = Math.max(minReconnectDelay, Math.min(this.nextRetryTime * reconnectBackoffFactor, maxReconnectDelay));\n    setTimeout(function () {\n      return _this.openNewWebSocket();\n    }, retryTime);\n    var retryTimeSeconds = retryTime / 1000 | 0;\n    this.debugLog(\"WebSocket was closed. Re-opening in \" + retryTimeSeconds + \" seconds.\");\n  };\n\n  SturdyWebSocket.prototype.stopReconnecting = function (event, debugReason) {\n    this.debugLog(debugReason);\n    this.shutdown();\n\n    if (event) {\n      this.dispatchEventOfType(\"close\", event);\n    }\n  };\n\n  SturdyWebSocket.prototype.shutdown = function () {\n    this.isClosed = true;\n    this.clearAllTimeouts();\n    this.messageBuffer = [];\n    this.disposeSocket();\n  };\n\n  SturdyWebSocket.prototype.disposeSocket = function (closeCode, reason) {\n    if (!this.ws) {\n      return;\n    } // Use noop handlers instead of null because some WebSocket\n    // implementations, such as the one from isomorphic-ws, raise a stink on\n    // unhandled events.\n\n\n    this.ws.onerror = noop;\n    this.ws.onclose = noop;\n    this.ws.onmessage = noop;\n    this.ws.onopen = noop;\n    this.ws.close(closeCode, reason);\n    this.ws = undefined;\n  };\n\n  SturdyWebSocket.prototype.clearAllTimeouts = function () {\n    this.clearConnectTimeout();\n    this.clearAllClearTimeout();\n  };\n\n  SturdyWebSocket.prototype.clearConnectTimeout = function () {\n    if (this.connectTimeoutId != null) {\n      clearTimeout(this.connectTimeoutId);\n      this.connectTimeoutId = undefined;\n    }\n  };\n\n  SturdyWebSocket.prototype.clearAllClearTimeout = function () {\n    if (this.allClearTimeoutId != null) {\n      clearTimeout(this.allClearTimeoutId);\n      this.allClearTimeoutId = undefined;\n    }\n  };\n\n  SturdyWebSocket.prototype.dispatchEventOfType = function (type, event) {\n    var _this = this;\n\n    switch (type) {\n      case \"close\":\n        if (this.onclose) {\n          this.onclose(event);\n        }\n\n        break;\n\n      case \"error\":\n        if (this.onerror) {\n          this.onerror(event);\n        }\n\n        break;\n\n      case \"message\":\n        if (this.onmessage) {\n          this.onmessage(event);\n        }\n\n        break;\n\n      case \"open\":\n        if (this.onopen) {\n          this.onopen(event);\n        }\n\n        break;\n\n      case \"down\":\n        if (this.ondown) {\n          this.ondown(event);\n        }\n\n        break;\n\n      case \"reopen\":\n        if (this.onreopen) {\n          this.onreopen(event);\n        }\n\n        break;\n    }\n\n    if (type in this.listeners) {\n      this.listeners[type].slice().forEach(function (listener) {\n        return _this.callListener(listener, event);\n      });\n    }\n\n    return !event || !event.defaultPrevented;\n  };\n\n  SturdyWebSocket.prototype.callListener = function (listener, event) {\n    if (typeof listener === \"function\") {\n      listener.call(this, event);\n    } else {\n      listener.handleEvent.call(this, event);\n    }\n  };\n\n  SturdyWebSocket.prototype.debugLog = function (message) {\n    if (this.options.debug) {\n      // tslint:disable-next-line:no-console\n      console.log(message);\n    }\n  };\n\n  SturdyWebSocket.prototype.getTooManyFailedReconnectsMessage = function () {\n    var maxReconnectAttempts = this.options.maxReconnectAttempts;\n    return \"Failed to reconnect after \" + maxReconnectAttempts + \" \" + pluralize(\"attempt\", maxReconnectAttempts) + \". Closing permanently.\";\n  };\n\n  SturdyWebSocket.DEFAULT_OPTIONS = {\n    allClearResetTime: 5000,\n    connectTimeout: 5000,\n    debug: false,\n    minReconnectDelay: 1000,\n    maxReconnectDelay: 30000,\n    maxReconnectAttempts: Number.POSITIVE_INFINITY,\n    reconnectBackoffFactor: 1.5,\n    shouldReconnect: function shouldReconnect() {\n      return true;\n    },\n    wsConstructor: undefined\n  };\n  SturdyWebSocket.CONNECTING = 0;\n  SturdyWebSocket.OPEN = 1;\n  SturdyWebSocket.CLOSING = 2;\n  SturdyWebSocket.CLOSED = 3;\n  return SturdyWebSocket;\n}();\n\nexports.default = SturdyWebSocket;\n\nfunction applyDefaultOptions(options) {\n  var result = {};\n  Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(function (key) {\n    var value = options[key];\n    result[key] = value === undefined ? SturdyWebSocket.DEFAULT_OPTIONS[key] : value;\n  });\n  return result;\n}\n\nfunction getDataByteLength(data) {\n  if (typeof data === \"string\") {\n    // UTF-16 strings use two bytes per character.\n    return 2 * data.length;\n  } else if (data instanceof ArrayBuffer) {\n    return data.byteLength;\n  } else if (data instanceof Blob) {\n    return data.size;\n  } else {\n    return undefined;\n  }\n}\n\nfunction pluralize(s, n) {\n  return n === 1 ? s : s + \"s\";\n}\n\nfunction noop() {// Nothing.\n}","map":{"version":3,"mappings":"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","names":["SHOULD_RECONNECT_FALSE_MESSAGE","SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE","url","protocolsOrOptions","options","SturdyWebSocket","CONNECTING","OPEN","CLOSING","CLOSED","Array","isArray","protocols","applyDefaultOptions","wsConstructor","WebSocket","Error","openNewWebSocket","Object","binaryTypeInternal","binaryType","ws","sum","bufferedAmount","hasUnknownAmount","messageBuffer","forEach","byteLength","getDataByteLength","data","debugLog","extensions","lastKnownExtensions","protocol","lastKnownProtocol","isClosed","code","reason","disposeSocket","shutdown","readyState","send","push","handleClose","undefined","type","listener","listeners","event","dispatchEventOfType","filter","connectTimeout","onclose","onerror","handleError","onmessage","handleMessage","onopen","handleOpen","connectTimeoutId","setTimeout","_this","clearConnectTimeout","hasBeenOpened","message","allClearTimeoutId","clearAllClearTimeout","nextRetryTime","reconnectCount","openTime","allClearResetTime","maxReconnectAttempts","shouldReconnect","stopReconnecting","getTooManyFailedReconnectsMessage","willReconnect","handleWillReconnect","then","willReconnectResolved","denialReason","reestablishConnection","minReconnectDelay","maxReconnectDelay","reconnectBackoffFactor","retryTime","Math","max","min","retryTimeSeconds","debugReason","clearAllTimeouts","closeCode","noop","close","clearTimeout","ondown","onreopen","slice","callListener","defaultPrevented","call","handleEvent","debug","console","log","pluralize","Number","POSITIVE_INFINITY","result","keys","DEFAULT_OPTIONS","value","key","length","ArrayBuffer","Blob","size","s","n"],"sourceRoot":"","sources":["../src/index.ts"],"sourcesContent":["export interface Options {\n    allClearResetTime?: number;\n    connectTimeout?: number;\n    debug?: boolean;\n    minReconnectDelay?: number;\n    maxReconnectDelay?: number;\n    maxReconnectAttempts?: number;\n    reconnectBackoffFactor?: number;\n    wsConstructor?: new (url: string, protocols?: string | string[]) => any;\n    shouldReconnect?(closeEvent: CloseEvent): boolean | Promise<boolean>;\n}\n\ninterface SturdyWebSocketEventMap extends WebSocketEventMap {\n    down: CloseEvent;\n    reopen: Event;\n}\n\ntype WebSocketListener<K extends keyof SturdyWebSocketEventMap> = (\n    this: WebSocket,\n    event: SturdyWebSocketEventMap[K],\n) => any;\n\ntype WebSocketListeners = {\n    [K in keyof SturdyWebSocketEventMap]?: Array<WebSocketListener<K>>;\n} & {\n    [key: string]: EventListenerOrEventListenerObject[];\n};\n\nconst SHOULD_RECONNECT_FALSE_MESSAGE =\n    \"Provided shouldReconnect() returned false. Closing permanently.\";\nconst SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE =\n    \"Provided shouldReconnect() resolved to false. Closing permanently.\";\n\nexport default class SturdyWebSocket implements WebSocket {\n    public static readonly DEFAULT_OPTIONS: Required<Options> = {\n        allClearResetTime: 5000,\n        connectTimeout: 5000,\n        debug: false,\n        minReconnectDelay: 1000,\n        maxReconnectDelay: 30000,\n        maxReconnectAttempts: Number.POSITIVE_INFINITY,\n        reconnectBackoffFactor: 1.5,\n        shouldReconnect: () => true,\n        wsConstructor: undefined!,\n    };\n\n    public static readonly CONNECTING = 0;\n    public static readonly OPEN = 1;\n    public static readonly CLOSING = 2;\n    public static readonly CLOSED = 3;\n\n    public onclose: ((event: CloseEvent) => void) | null = null;\n    public onerror: ((event: Event) => void) | null = null;\n    public onmessage: ((event: MessageEvent) => void) | null = null;\n    public onopen: ((event: Event) => void) | null = null;\n    public ondown: ((event: CloseEvent | undefined) => void) | null = null;\n    public onreopen: ((event: Event) => void) | null = null;\n    public readonly CONNECTING = SturdyWebSocket.CONNECTING;\n    public readonly OPEN = SturdyWebSocket.OPEN;\n    public readonly CLOSING = SturdyWebSocket.CLOSING;\n    public readonly CLOSED = SturdyWebSocket.CLOSED;\n\n    private readonly protocols?: string | string[];\n    private readonly options: Required<Options>;\n    private ws?: WebSocket;\n    private hasBeenOpened = false;\n    private isClosed = false;\n    private messageBuffer: any[] = [];\n    private nextRetryTime: number = 0;\n    private reconnectCount = 0;\n    private allClearTimeoutId?: any;\n    private connectTimeoutId?: any;\n    private binaryTypeInternal?: BinaryType;\n    private lastKnownExtensions = \"\";\n    private lastKnownProtocol = \"\";\n    private readonly listeners: WebSocketListeners = {};\n\n    constructor(url: string, options?: Options);\n    constructor(\n        url: string,\n        protocols: string | string[] | undefined,\n        options?: Options,\n    );\n    constructor(\n        public readonly url: string,\n        protocolsOrOptions?: string | string[] | Options,\n        options: Options = {},\n    ) {\n        if (\n            protocolsOrOptions == null ||\n            typeof protocolsOrOptions === \"string\" ||\n            Array.isArray(protocolsOrOptions)\n        ) {\n            this.protocols = protocolsOrOptions;\n        } else {\n            options = protocolsOrOptions;\n        }\n        this.options = applyDefaultOptions(options);\n        if (!this.options.wsConstructor) {\n            if (typeof WebSocket !== \"undefined\") {\n                this.options.wsConstructor = WebSocket;\n            } else {\n                throw new Error(\n                    \"WebSocket not present in global scope and no \" +\n                        \"wsConstructor option was provided.\",\n                );\n            }\n        }\n        this.openNewWebSocket();\n    }\n\n    public get binaryType(): BinaryType {\n        return this.binaryTypeInternal || \"blob\";\n    }\n\n    public set binaryType(binaryType: BinaryType) {\n        this.binaryTypeInternal = binaryType;\n        if (this.ws) {\n            this.ws.binaryType = binaryType;\n        }\n    }\n\n    public get bufferedAmount(): number {\n        let sum = this.ws ? this.ws.bufferedAmount : 0;\n        let hasUnknownAmount = false;\n        this.messageBuffer.forEach(data => {\n            const byteLength = getDataByteLength(data);\n            if (byteLength != null) {\n                sum += byteLength;\n            } else {\n                hasUnknownAmount = true;\n            }\n        });\n        if (hasUnknownAmount) {\n            this.debugLog(\n                \"Some buffered data had unknown length. bufferedAmount()\" +\n                    \" return value may be below the correct amount.\",\n            );\n        }\n        return sum;\n    }\n\n    public get extensions(): string {\n        return this.ws ? this.ws.extensions : this.lastKnownExtensions;\n    }\n\n    public get protocol(): string {\n        return this.ws ? this.ws.protocol : this.lastKnownProtocol;\n    }\n\n    public get readyState(): number {\n        return this.isClosed ? SturdyWebSocket.CLOSED : SturdyWebSocket.OPEN;\n    }\n\n    public close(code?: number, reason?: string): void {\n        this.disposeSocket(code, reason);\n        this.shutdown();\n        this.debugLog(\"WebSocket permanently closed by client.\");\n    }\n\n    public send(data: any): void {\n        if (this.isClosed) {\n            throw new Error(\"WebSocket is already in CLOSING or CLOSED state.\");\n        } else if (this.ws && this.ws.readyState === this.OPEN) {\n            this.ws.send(data);\n        } else {\n            this.messageBuffer.push(data);\n        }\n    }\n\n    public reconnect(): void {\n        if (this.isClosed) {\n            throw new Error(\n                \"Cannot call reconnect() on socket which is permanently closed.\",\n            );\n        }\n        this.disposeSocket(1000, \"Client requested reconnect.\");\n        this.handleClose(undefined);\n    }\n\n    public addEventListener<K extends keyof SturdyWebSocketEventMap>(\n        type: K,\n        listener: (this: WebSocket, event: SturdyWebSocketEventMap[K]) => void,\n    ): void;\n    public addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void;\n    public addEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void {\n        if (!this.listeners[type]) {\n            this.listeners[type] = [];\n        }\n        this.listeners[type].push(listener);\n    }\n\n    public dispatchEvent(event: Event): boolean {\n        return this.dispatchEventOfType(event.type, event);\n    }\n\n    public removeEventListener<K extends keyof SturdyWebSocketEventMap>(\n        type: K,\n        listener: (this: WebSocket, event: SturdyWebSocketEventMap[K]) => void,\n    ): void;\n    public removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void;\n    public removeEventListener(\n        type: string,\n        listener: EventListenerOrEventListenerObject,\n    ): void {\n        if (this.listeners[type]) {\n            this.listeners[type] = this.listeners[type].filter(\n                l => l !== listener,\n            );\n        }\n    }\n\n    private openNewWebSocket(): void {\n        if (this.isClosed) {\n            return;\n        }\n        const { connectTimeout, wsConstructor } = this.options;\n        this.debugLog(`Opening new WebSocket to ${this.url}.`);\n        const ws: WebSocket = new wsConstructor(this.url, this.protocols);\n        ws.onclose = event => this.handleClose(event);\n        ws.onerror = event => this.handleError(event);\n        ws.onmessage = event => this.handleMessage(event);\n        ws.onopen = event => this.handleOpen(event);\n        this.connectTimeoutId = setTimeout(() => {\n            // If this is running, we still haven't opened the websocket.\n            // Kill it so we can try again.\n            this.clearConnectTimeout();\n            this.disposeSocket();\n            this.handleClose(undefined);\n        }, connectTimeout);\n        this.ws = ws;\n    }\n\n    private handleOpen(event: Event): void {\n        if (!this.ws || this.isClosed) {\n            return;\n        }\n        const { allClearResetTime } = this.options;\n        this.debugLog(\"WebSocket opened.\");\n        if (this.binaryTypeInternal != null) {\n            this.ws.binaryType = this.binaryTypeInternal;\n        } else {\n            this.binaryTypeInternal = this.ws.binaryType;\n        }\n        this.clearConnectTimeout();\n        if (this.hasBeenOpened) {\n            this.dispatchEventOfType(\"reopen\", event);\n        } else {\n            this.dispatchEventOfType(\"open\", event);\n            this.hasBeenOpened = true;\n        }\n        this.messageBuffer.forEach(message => this.send(message));\n        this.messageBuffer = [];\n        this.allClearTimeoutId = setTimeout(() => {\n            this.clearAllClearTimeout();\n            this.nextRetryTime = 0;\n            this.reconnectCount = 0;\n            const openTime = (allClearResetTime / 1000) | 0;\n            this.debugLog(\n                `WebSocket remained open for ${openTime} seconds. Resetting` +\n                    \" retry time and count.\",\n            );\n        }, allClearResetTime);\n    }\n\n    private handleMessage(event: MessageEvent): void {\n        if (this.isClosed) {\n            return;\n        }\n        this.dispatchEventOfType(\"message\", event);\n    }\n\n    private handleClose(event: CloseEvent | undefined): void {\n        if (this.isClosed) {\n            return;\n        }\n        const { maxReconnectAttempts, shouldReconnect } = this.options;\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n        if (this.ws) {\n            this.lastKnownExtensions = this.ws.extensions;\n            this.lastKnownProtocol = this.ws.protocol;\n            this.disposeSocket();\n        }\n        this.dispatchEventOfType(\"down\", event);\n        if (this.reconnectCount >= maxReconnectAttempts) {\n            this.stopReconnecting(\n                event,\n                this.getTooManyFailedReconnectsMessage(),\n            );\n            return;\n        }\n        const willReconnect = !event || shouldReconnect(event);\n        if (typeof willReconnect === \"boolean\") {\n            this.handleWillReconnect(\n                willReconnect,\n                event,\n                SHOULD_RECONNECT_FALSE_MESSAGE,\n            );\n        } else {\n            willReconnect.then(willReconnectResolved => {\n                if (this.isClosed) {\n                    return;\n                }\n                this.handleWillReconnect(\n                    willReconnectResolved,\n                    event,\n                    SHOULD_RECONNECT_PROMISE_FALSE_MESSAGE,\n                );\n            });\n        }\n    }\n\n    private handleError(event: Event): void {\n        this.dispatchEventOfType(\"error\", event);\n        this.debugLog(\"WebSocket encountered an error.\");\n    }\n\n    private handleWillReconnect(\n        willReconnect: boolean,\n        event: CloseEvent | undefined,\n        denialReason: string,\n    ): void {\n        if (willReconnect) {\n            this.reestablishConnection();\n        } else {\n            this.stopReconnecting(event, denialReason);\n        }\n    }\n\n    private reestablishConnection(): void {\n        const {\n            minReconnectDelay,\n            maxReconnectDelay,\n            reconnectBackoffFactor,\n        } = this.options;\n        this.reconnectCount++;\n        const retryTime = this.nextRetryTime;\n        this.nextRetryTime = Math.max(\n            minReconnectDelay,\n            Math.min(\n                this.nextRetryTime * reconnectBackoffFactor,\n                maxReconnectDelay,\n            ),\n        );\n        setTimeout(() => this.openNewWebSocket(), retryTime);\n        const retryTimeSeconds = (retryTime / 1000) | 0;\n        this.debugLog(\n            `WebSocket was closed. Re-opening in ${retryTimeSeconds} seconds.`,\n        );\n    }\n\n    private stopReconnecting(\n        event: CloseEvent | undefined,\n        debugReason: string,\n    ): void {\n        this.debugLog(debugReason);\n        this.shutdown();\n        if (event) {\n            this.dispatchEventOfType(\"close\", event);\n        }\n    }\n\n    private shutdown(): void {\n        this.isClosed = true;\n        this.clearAllTimeouts();\n        this.messageBuffer = [];\n        this.disposeSocket();\n    }\n\n    private disposeSocket(closeCode?: number, reason?: string): void {\n        if (!this.ws) {\n            return;\n        }\n        // Use noop handlers instead of null because some WebSocket\n        // implementations, such as the one from isomorphic-ws, raise a stink on\n        // unhandled events.\n        this.ws.onerror = noop;\n        this.ws.onclose = noop;\n        this.ws.onmessage = noop;\n        this.ws.onopen = noop;\n        this.ws.close(closeCode, reason);\n        this.ws = undefined;\n    }\n\n    private clearAllTimeouts(): void {\n        this.clearConnectTimeout();\n        this.clearAllClearTimeout();\n    }\n\n    private clearConnectTimeout(): void {\n        if (this.connectTimeoutId != null) {\n            clearTimeout(this.connectTimeoutId);\n            this.connectTimeoutId = undefined;\n        }\n    }\n\n    private clearAllClearTimeout(): void {\n        if (this.allClearTimeoutId != null) {\n            clearTimeout(this.allClearTimeoutId);\n            this.allClearTimeoutId = undefined;\n        }\n    }\n\n    private dispatchEventOfType(type: string, event: any): boolean {\n        switch (type) {\n            case \"close\":\n                if (this.onclose) {\n                    this.onclose(event);\n                }\n                break;\n            case \"error\":\n                if (this.onerror) {\n                    this.onerror(event);\n                }\n                break;\n            case \"message\":\n                if (this.onmessage) {\n                    this.onmessage(event);\n                }\n                break;\n            case \"open\":\n                if (this.onopen) {\n                    this.onopen(event);\n                }\n                break;\n            case \"down\":\n                if (this.ondown) {\n                    this.ondown(event);\n                }\n                break;\n            case \"reopen\":\n                if (this.onreopen) {\n                    this.onreopen(event);\n                }\n                break;\n        }\n        if (type in this.listeners) {\n            this.listeners[type]\n                .slice()\n                .forEach(listener => this.callListener(listener, event));\n        }\n        return !event || !(event as Event).defaultPrevented;\n    }\n\n    private callListener(\n        listener: EventListenerOrEventListenerObject,\n        event: Event,\n    ): void {\n        if (typeof listener === \"function\") {\n            listener.call(this, event);\n        } else {\n            listener.handleEvent.call(this, event);\n        }\n    }\n\n    private debugLog(message: string): void {\n        if (this.options.debug) {\n            // tslint:disable-next-line:no-console\n            console.log(message);\n        }\n    }\n\n    private getTooManyFailedReconnectsMessage(): string {\n        const { maxReconnectAttempts } = this.options;\n        return `Failed to reconnect after ${maxReconnectAttempts} ${pluralize(\n            \"attempt\",\n            maxReconnectAttempts,\n        )}. Closing permanently.`;\n    }\n}\n\nfunction applyDefaultOptions(options: Options): Required<Options> {\n    const result: any = {};\n    Object.keys(SturdyWebSocket.DEFAULT_OPTIONS).forEach(key => {\n        const value = (options as any)[key];\n        result[key] =\n            value === undefined\n                ? (SturdyWebSocket.DEFAULT_OPTIONS as any)[key]\n                : value;\n    });\n    return result;\n}\n\nfunction getDataByteLength(data: any): number | undefined {\n    if (typeof data === \"string\") {\n        // UTF-16 strings use two bytes per character.\n        return 2 * data.length;\n    } else if (data instanceof ArrayBuffer) {\n        return data.byteLength;\n    } else if (data instanceof Blob) {\n        return data.size;\n    } else {\n        return undefined;\n    }\n}\n\nfunction pluralize(s: string, n: number): string {\n    return n === 1 ? s : `${s}s`;\n}\n\nfunction noop(): void {\n    // Nothing.\n}\n"]},"metadata":{},"sourceType":"script"}